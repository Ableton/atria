<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.9.1"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <script type="text/javascript" src="http://stevenbenner.github.io/jquery-powertip/scripts/jquery.powertip.js"></script>
        <title>Atria: atria::xform Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link rel="stylesheet" href="http://bootswatch.com/journal/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
        <link href="style.css" rel="stylesheet" type="text/css"/>
    </head>
      <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <span class="navbar-brand">Atria </span>
                </div>
                <div class="navbar-header">
                  <span class="navbar-brand brief">Modern C++ toolkit</span>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceatria.html">atria</a></li><li class="navelem"><a class="el" href="namespaceatria_1_1xform.html">xform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">atria::xform Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Efficient and flexible C++ implementation of transducers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatria_1_1xform_1_1any__state.html">any_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphically holds any value implementing the <code><a class="el" href="structatria_1_1xform_1_1state__traits.html" title="Interface for a type specializing the State concept. ">state_traits</a></code>.  <a href="classatria_1_1xform_1_1any__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1emplace__back__rf__t.html">emplace_back_rf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reducing function that emplaces back at the collection that is uses as state.  <a href="structatria_1_1xform_1_1emplace__back__rf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1first__rf__t.html">first_rf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reducing function that always returns the initial state.  <a href="structatria_1_1xform_1_1first__rf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1is__skip__state.html">is_skip_state</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1is__skip__state_3_01skip__state_3_01_skipped_t_00_01_called_t_01_4_01_4.html">is_skip_state&lt; skip_state&lt; SkippedT, CalledT &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1is__state__wrapper.html">is_state_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction returning whether <code>StateT</code> is a, or reference to, a <code><a class="el" href="structatria_1_1xform_1_1state__wrapper.html" title="A decorator for the accumulator of a reduction. ">state_wrapper</a></code> instantiation.  <a href="structatria_1_1xform_1_1is__state__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1is__state__wrapper_3_01___00_01state__wrapper_3_01_t_00_01_s_00_01_d_01_4_01_4.html">is_state_wrapper&lt; _, state_wrapper&lt; T, S, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1last__rf__t.html">last_rf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reducing function that emplaces back at the collection that is uses as state.  <a href="structatria_1_1xform_1_1last__rf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1maybe__reduced__tag.html">maybe_reduced_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for <code>maybe_reduced</code> state wrapper.  <a href="structatria_1_1xform_1_1maybe__reduced__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1no__tag.html">no_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default tag for <code><a class="el" href="structatria_1_1xform_1_1state__wrapper.html" title="A decorator for the accumulator of a reduction. ">state_wrapper</a></code>.  <a href="structatria_1_1xform_1_1no__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1output__rf__t.html">output_rf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reducing function that outputs through the iterator that is carried as state.  <a href="structatria_1_1xform_1_1output__rf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1skip__result.html">skip_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction that returns a type that can hold both values of type <code>skipped_t = StateT</code> and <code>wrapped_t = declval&lt;ReducingFnT&gt;(declval&lt;StateT&gt;(), declval&lt;InputTs&gt;()...)</code>  <a href="structatria_1_1xform_1_1skip__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1skip__state.html">skip_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-safe union type that can hold values of both <em>SkippedT</em> and <em>CalledT</em> types.  <a href="structatria_1_1xform_1_1skip__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1state__traits.html">state_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a type specializing the <code>State</code> concept.  <a href="structatria_1_1xform_1_1state__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1state__traits_3_01any__state_01_4.html">state_traits&lt; any_state &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1state__traits_3_01skip__state_3_01_skipped_t_00_01_called_t_01_4_01_4.html">state_traits&lt; skip_state&lt; SkippedT, CalledT &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1state__traits_3_01state__wrapper_3_01_tag_t_00_01_state_t_00_01_data_t_01_4_01_4.html">state_traits&lt; state_wrapper&lt; TagT, StateT, DataT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State traits specialization for <code><a class="el" href="structatria_1_1xform_1_1state__wrapper.html" title="A decorator for the accumulator of a reduction. ">state_wrapper</a></code>.  <a href="structatria_1_1xform_1_1state__traits_3_01state__wrapper_3_01_tag_t_00_01_state_t_00_01_data_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1state__wrapper.html">state_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A decorator for the accumulator of a reduction.  <a href="structatria_1_1xform_1_1state__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to write simple transducers easily.  <a href="structatria_1_1xform_1_1transducer__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af2572203f7496bd93e991b7dbaa2772e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2572203f7496bd93e991b7dbaa2772e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#af2572203f7496bd93e991b7dbaa2772e">maybe_reduced</a> = <a class="el" href="structatria_1_1xform_1_1state__wrapper.html">state_wrapper</a>&lt; <a class="el" href="structatria_1_1xform_1_1maybe__reduced__tag.html">maybe_reduced_tag</a>, T, bool &gt;</td></tr>
<tr class="memdesc:af2572203f7496bd93e991b7dbaa2772e"><td class="mdescLeft">&#160;</td><td class="mdescRight">State wrapper for transducers that may want to signal that the reduction is finished.  <a href="#af2572203f7496bd93e991b7dbaa2772e">More...</a><br /></td></tr>
<tr class="separator:af2572203f7496bd93e991b7dbaa2772e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac710c4d9d1eee12a88e23161cd1eb5b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac710c4d9d1eee12a88e23161cd1eb5b4"></a>
template&lt;typename ReducingFnT , typename StateT , typename... InputTs&gt; </td></tr>
<tr class="memitem:ac710c4d9d1eee12a88e23161cd1eb5b4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>skip_result_t</b> = typename <a class="el" href="structatria_1_1xform_1_1skip__result.html">skip_result</a>&lt; ReducingFnT, StateT, InputTs...&gt;::type</td></tr>
<tr class="separator:ac710c4d9d1eee12a88e23161cd1eb5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d25bac061e130db829fe0e053766bc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a79d25bac061e130db829fe0e053766bc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79d25bac061e130db829fe0e053766bc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>state_traits_t</b> = <a class="el" href="structatria_1_1xform_1_1state__traits.html">state_traits</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a79d25bac061e130db829fe0e053766bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6836963593c68b6b5f9cf2fd93ede8f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6836963593c68b6b5f9cf2fd93ede8f7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cat_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::cat_rf_gen &gt;</td></tr>
<tr class="separator:a6836963593c68b6b5f9cf2fd93ede8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd93346a11a45dd9c7795f931d3dd0af"><td class="memTemplParams" colspan="2"><a class="anchor" id="afd93346a11a45dd9c7795f931d3dd0af"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd93346a11a45dd9c7795f931d3dd0af"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chainr_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::chainr_rf_gen, T &gt;</td></tr>
<tr class="separator:afd93346a11a45dd9c7795f931d3dd0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9054a737229a3c25c6e746b48c3232a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9054a737229a3c25c6e746b48c3232a4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9054a737229a3c25c6e746b48c3232a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chainl_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::chainl_rf_gen, T &gt;</td></tr>
<tr class="separator:a9054a737229a3c25c6e746b48c3232a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c75d93547afbe50b73289c4604715a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a51c75d93547afbe50b73289c4604715a"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a51c75d93547afbe50b73289c4604715a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::count_rf_gen, T1, T2 &gt;</td></tr>
<tr class="separator:a51c75d93547afbe50b73289c4604715a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6cdf490b5ee9981563ede19d967f12"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2e6cdf490b5ee9981563ede19d967f12"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e6cdf490b5ee9981563ede19d967f12"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cycle_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::cycle_rf_gen, T &gt;</td></tr>
<tr class="separator:a2e6cdf490b5ee9981563ede19d967f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b4111e25fd8a4d8ba47bf981d445ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5b4111e25fd8a4d8ba47bf981d445ea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>dedupe_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::dedupe_rf_gen &gt;</td></tr>
<tr class="separator:aa5b4111e25fd8a4d8ba47bf981d445ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44060a96919902f1800950981c5b7f97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44060a96919902f1800950981c5b7f97"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>distinct_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::distinct_rf_gen &gt;</td></tr>
<tr class="separator:a44060a96919902f1800950981c5b7f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a29a43314034d88e68df3af3b2196d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae8a29a43314034d88e68df3af3b2196d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8a29a43314034d88e68df3af3b2196d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>drop_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::drop_rf_gen, T &gt;</td></tr>
<tr class="separator:ae8a29a43314034d88e68df3af3b2196d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2aac2b68b289aa97d562b26c6f7bab"><td class="memTemplParams" colspan="2"><a class="anchor" id="acd2aac2b68b289aa97d562b26c6f7bab"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd2aac2b68b289aa97d562b26c6f7bab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>drop_while_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::drop_while_rf_gen, T &gt;</td></tr>
<tr class="separator:acd2aac2b68b289aa97d562b26c6f7bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bf086d9f28b0d80025e5295433ad17"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac7bf086d9f28b0d80025e5295433ad17"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7bf086d9f28b0d80025e5295433ad17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enumerate_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::enumerate_rf_gen, T &gt;</td></tr>
<tr class="separator:ac7bf086d9f28b0d80025e5295433ad17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7901b87e333dac17c179ee4e057b55"><td class="memTemplParams" colspan="2"><a class="anchor" id="ade7901b87e333dac17c179ee4e057b55"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade7901b87e333dac17c179ee4e057b55"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>filter_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::filter_rf_gen, T &gt;</td></tr>
<tr class="separator:ade7901b87e333dac17c179ee4e057b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12255ab35c421796b9dd6ba97c7d8ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab12255ab35c421796b9dd6ba97c7d8ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>interleave_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::interleave_rf_gen &gt;</td></tr>
<tr class="separator:ab12255ab35c421796b9dd6ba97c7d8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4007c9d3f153ec855a9ddf7af8fa7f78"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4007c9d3f153ec855a9ddf7af8fa7f78"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a4007c9d3f153ec855a9ddf7af8fa7f78"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interpose_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::interpose_rf_gen, T1, T2 &gt;</td></tr>
<tr class="separator:a4007c9d3f153ec855a9ddf7af8fa7f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1336eeab4d1343748fae24cb1a8f3269"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1336eeab4d1343748fae24cb1a8f3269"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1336eeab4d1343748fae24cb1a8f3269"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iter_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::iter_rf_gen, T &gt;</td></tr>
<tr class="separator:a1336eeab4d1343748fae24cb1a8f3269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fa80c7e219ee304a26ed4ef67d7cd5"><td class="memTemplParams" colspan="2"><a class="anchor" id="af1fa80c7e219ee304a26ed4ef67d7cd5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1fa80c7e219ee304a26ed4ef67d7cd5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::map_rf_gen, T &gt;</td></tr>
<tr class="separator:af1fa80c7e219ee304a26ed4ef67d7cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35583334321813d89e62cd3f85a8dc4f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a35583334321813d89e62cd3f85a8dc4f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35583334321813d89e62cd3f85a8dc4f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>partition_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::partition_rf_gen, T &gt;</td></tr>
<tr class="separator:a35583334321813d89e62cd3f85a8dc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa606207b408e431c5af3f682725ea078"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa606207b408e431c5af3f682725ea078"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa606207b408e431c5af3f682725ea078"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>partition_by_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::partition_by_rf_gen, T &gt;</td></tr>
<tr class="separator:aa606207b408e431c5af3f682725ea078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7301a03a6eab93394d35b1e438bef85d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7301a03a6eab93394d35b1e438bef85d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7301a03a6eab93394d35b1e438bef85d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>product_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::product_rf_gen, T &gt;</td></tr>
<tr class="separator:a7301a03a6eab93394d35b1e438bef85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a956f817d84fd93fe4fab9c884923b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a58a956f817d84fd93fe4fab9c884923b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58a956f817d84fd93fe4fab9c884923b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>repeat_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::repeat_rf_gen, T &gt;</td></tr>
<tr class="separator:a58a956f817d84fd93fe4fab9c884923b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cf5bcd9b117856aaebebbfa4a00ea6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a71cf5bcd9b117856aaebebbfa4a00ea6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71cf5bcd9b117856aaebebbfa4a00ea6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>take_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::take_rf_gen, T &gt;</td></tr>
<tr class="separator:a71cf5bcd9b117856aaebebbfa4a00ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57130aeacd01224e16df6fe1c3fe8fd6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a57130aeacd01224e16df6fe1c3fe8fd6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57130aeacd01224e16df6fe1c3fe8fd6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>take_nth_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::take_nth_rf_gen, T &gt;</td></tr>
<tr class="separator:a57130aeacd01224e16df6fe1c3fe8fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2412982fd714eb86330896c02b927bec"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2412982fd714eb86330896c02b927bec"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2412982fd714eb86330896c02b927bec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>take_while_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::take_while_rf_gen, T &gt;</td></tr>
<tr class="separator:a2412982fd714eb86330896c02b927bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e4b8c9b4281bf93d4e649374f2d389"><td class="memTemplParams" colspan="2">template&lt;typename InputT  = meta::pack&lt;&gt;, typename OutputT  = InputT&gt; </td></tr>
<tr class="memitem:a12e4b8c9b4281bf93d4e649374f2d389"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a12e4b8c9b4281bf93d4e649374f2d389">transducer</a> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; <a class="el" href="namespaceatria_1_1meta.html#a11375eeae94b43372dd0f70a867f200f">meta::unpack</a>&lt; detail::transducer_rf_gen, OutputT &gt;, detail::transducer_function_t&lt; InputT, OutputT &gt; &gt;</td></tr>
<tr class="memdesc:a12e4b8c9b4281bf93d4e649374f2d389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type erased transducer.  <a href="#a12e4b8c9b4281bf93d4e649374f2d389">More...</a><br /></td></tr>
<tr class="separator:a12e4b8c9b4281bf93d4e649374f2d389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dde26033af3e70f68f4d38bde361da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1dde26033af3e70f68f4d38bde361da"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>unzip_t</b> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; detail::unzip_rf_gen &gt;</td></tr>
<tr class="separator:ab1dde26033af3e70f68f4d38bde361da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6f09f6f468f00951f63d476cf3f200a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a6f09f6f468f00951f63d476cf3f200a2">ABL_CONCEPT_SPEC</a> (State)</td></tr>
<tr class="memdesc:a6f09f6f468f00951f63d476cf3f200a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for a type that can be used as a <code>state</code> of a reducing function.  <a href="#a6f09f6f468f00951f63d476cf3f200a2">More...</a><br /></td></tr>
<tr class="separator:a6f09f6f468f00951f63d476cf3f200a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d61103acf5e43b32458b61b4fb5c42f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a5d61103acf5e43b32458b61b4fb5c42f">ABL_CONCEPT_SPEC</a> (Reducing_function)</td></tr>
<tr class="memdesc:a5d61103acf5e43b32458b61b4fb5c42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for a function that can be used with <code>reduce</code> for a specific state and inputs.  <a href="#a5d61103acf5e43b32458b61b4fb5c42f">More...</a><br /></td></tr>
<tr class="separator:a5d61103acf5e43b32458b61b4fb5c42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80625416b5ebf0ce957cd1fd296ed80c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a80625416b5ebf0ce957cd1fd296ed80c">ABL_CONCEPT_SPEC</a> (Transducer)</td></tr>
<tr class="memdesc:a80625416b5ebf0ce957cd1fd296ed80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for a <code>transducer</code>, this is, a function that takes a <em>reducing function</em> as an argument, and decorates it returning a new <em>reducing function</em>.  <a href="#a80625416b5ebf0ce957cd1fd296ed80c">More...</a><br /></td></tr>
<tr class="separator:a80625416b5ebf0ce957cd1fd296ed80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50c949c55e49a934999f8724e805309"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#ae50c949c55e49a934999f8724e805309">ABL_CONCEPT_SPEC</a> (Transparent_transducer)</td></tr>
<tr class="memdesc:ae50c949c55e49a934999f8724e805309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for a transducer that can be applied over any arguments.  <a href="#ae50c949c55e49a934999f8724e805309">More...</a><br /></td></tr>
<tr class="separator:ae50c949c55e49a934999f8724e805309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acde91bb38a74e8111d03f72f991470"><td class="memTemplParams" colspan="2">template&lt;typename CollectionT , typename XformT , typename... InputRangeTs&gt; </td></tr>
<tr class="memitem:a8acde91bb38a74e8111d03f72f991470"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a8acde91bb38a74e8111d03f72f991470">into</a> (CollectionT &amp;&amp;col, XformT &amp;&amp;xform, InputRangeTs &amp;&amp;...ranges) -&gt; CollectionT &amp;&amp;</td></tr>
<tr class="memdesc:a8acde91bb38a74e8111d03f72f991470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/into$4.  <a href="#a8acde91bb38a74e8111d03f72f991470">More...</a><br /></td></tr>
<tr class="separator:a8acde91bb38a74e8111d03f72f991470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89301f0fadabb5c6ca41b05957d52eb"><td class="memTemplParams" colspan="2">template&lt;typename XformT , typename... InputRangeTs&gt; </td></tr>
<tr class="memitem:ac89301f0fadabb5c6ca41b05957d52eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#ac89301f0fadabb5c6ca41b05957d52eb">into_vector</a> (XformT &amp;&amp;xform, InputRangeTs &amp;&amp;...ranges) -&gt; detail::into_vector_result_t&lt; XformT, InputRangeTs...&gt;</td></tr>
<tr class="memdesc:ac89301f0fadabb5c6ca41b05957d52eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/into-array.  <a href="#ac89301f0fadabb5c6ca41b05957d52eb">More...</a><br /></td></tr>
<tr class="separator:ac89301f0fadabb5c6ca41b05957d52eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a64448ae730f052da1d9504e9e8d5c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a64448ae730f052da1d9504e9e8d5c2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>state_wrapper_data_is_reduced</b> (<a class="el" href="structatria_1_1xform_1_1maybe__reduced__tag.html">maybe_reduced_tag</a>, bool is_reduced)</td></tr>
<tr class="separator:a2a64448ae730f052da1d9504e9e8d5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdbd85097477b77c5b4e744753e29b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1cdbd85097477b77c5b4e744753e29b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a1cdbd85097477b77c5b4e744753e29b8">reduced_if</a> (T &amp;&amp;x, bool is_reduced) -&gt; <a class="el" href="namespaceatria_1_1xform.html#af2572203f7496bd93e991b7dbaa2772e">maybe_reduced</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a1cdbd85097477b77c5b4e744753e29b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <em>x</em> in a <code>maybe_reduced</code>, where <code>is_reduced</code> contains whether the reduction should actually finish.  <a href="#a1cdbd85097477b77c5b4e744753e29b8">More...</a><br /></td></tr>
<tr class="separator:a1cdbd85097477b77c5b4e744753e29b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b1401b1b47815969ff0867ad21f4e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27b1401b1b47815969ff0867ad21f4e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a27b1401b1b47815969ff0867ad21f4e5">reduced</a> (T &amp;&amp;x) -&gt; decltype(<a class="el" href="namespaceatria_1_1xform.html#a1cdbd85097477b77c5b4e744753e29b8">reduced_if</a>(std::forward&lt; T &gt;(x), true))</td></tr>
<tr class="memdesc:a27b1401b1b47815969ff0867ad21f4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <em>x</em> such that the reduction should finish.  <a href="#a27b1401b1b47815969ff0867ad21f4e5">More...</a><br /></td></tr>
<tr class="separator:a27b1401b1b47815969ff0867ad21f4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959ceb0a8362e3e5e4ef9f0a73a163c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a959ceb0a8362e3e5e4ef9f0a73a163c9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a959ceb0a8362e3e5e4ef9f0a73a163c9">not_reduced</a> (T &amp;&amp;x) -&gt; decltype(<a class="el" href="namespaceatria_1_1xform.html#a1cdbd85097477b77c5b4e744753e29b8">reduced_if</a>(std::forward&lt; T &gt;(x), false))</td></tr>
<tr class="memdesc:a959ceb0a8362e3e5e4ef9f0a73a163c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <em>x</em> such that the reduction should continue.  <a href="#a959ceb0a8362e3e5e4ef9f0a73a163c9">More...</a><br /></td></tr>
<tr class="separator:a959ceb0a8362e3e5e4ef9f0a73a163c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85da5e5fc0bf1b8b7ccf1eaf11b7fd80"><td class="memTemplParams" colspan="2">template&lt;typename ReducingFnT , typename StateT , typename... InputRangeTs&gt; </td></tr>
<tr class="memitem:a85da5e5fc0bf1b8b7ccf1eaf11b7fd80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a85da5e5fc0bf1b8b7ccf1eaf11b7fd80">reduce</a> (ReducingFnT &amp;&amp;step, StateT &amp;&amp;state, InputRangeTs &amp;&amp;...ranges) -&gt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; StateT &gt;</td></tr>
<tr class="memdesc:a85da5e5fc0bf1b8b7ccf1eaf11b7fd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/reduce.  <a href="#a85da5e5fc0bf1b8b7ccf1eaf11b7fd80">More...</a><br /></td></tr>
<tr class="separator:a85da5e5fc0bf1b8b7ccf1eaf11b7fd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab186465bd44d27bfa0a657c96592c36e"><td class="memTemplParams" colspan="2">template&lt;typename ReducingFnT , typename StateT , typename... InputRangeTs&gt; </td></tr>
<tr class="memitem:ab186465bd44d27bfa0a657c96592c36e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#ab186465bd44d27bfa0a657c96592c36e">reduce_nested</a> (ReducingFnT &amp;&amp;step, StateT &amp;&amp;state, InputRangeTs &amp;&amp;...ranges) -&gt; decltype(detail::is_non_empty(ranges...)?<a class="el" href="namespaceatria_1_1xform.html#a2da0bbda0517148bb5c7a784235bf88c">call</a>(detail::reduce_nested_non_empty_flipped, std::forward&lt; StateT &gt;(state), std::forward&lt; ReducingFnT &gt;(step), std::forward&lt; InputRangeTs &gt;(ranges)...):<a class="el" href="namespaceatria_1_1xform.html#a1cb9f11ae0e3df98b2c2e1f39f5302f2">skip</a>(std::forward&lt; StateT &gt;(state)))</td></tr>
<tr class="memdesc:ab186465bd44d27bfa0a657c96592c36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <em>reduce</em>, but does not unwrap <code>reduced</code> values.  <a href="#ab186465bd44d27bfa0a657c96592c36e">More...</a><br /></td></tr>
<tr class="separator:ab186465bd44d27bfa0a657c96592c36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb9f11ae0e3df98b2c2e1f39f5302f2"><td class="memTemplParams" colspan="2">template&lt;typename ReducingFnT , typename StateT , typename... InputTs&gt; </td></tr>
<tr class="memitem:a1cb9f11ae0e3df98b2c2e1f39f5302f2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a1cb9f11ae0e3df98b2c2e1f39f5302f2">skip</a> (ReducingFnT &amp;&amp;, StateT &amp;&amp;state, InputTs &amp;&amp;...) -&gt; skip_result_t&lt; ReducingFnT, StateT, InputTs...&gt;</td></tr>
<tr class="memdesc:a1cb9f11ae0e3df98b2c2e1f39f5302f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip calling the next reducing function in a transducer.  <a href="#a1cb9f11ae0e3df98b2c2e1f39f5302f2">More...</a><br /></td></tr>
<tr class="separator:a1cb9f11ae0e3df98b2c2e1f39f5302f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57226447f23dc4d69558ad83d1ada0e8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a57226447f23dc4d69558ad83d1ada0e8"></a>
template&lt;typename StateT &gt; </td></tr>
<tr class="memitem:a57226447f23dc4d69558ad83d1ada0e8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>skip</b> (StateT &amp;&amp;state) -&gt; StateT &amp;&amp;</td></tr>
<tr class="separator:a57226447f23dc4d69558ad83d1ada0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da0bbda0517148bb5c7a784235bf88c"><td class="memTemplParams" colspan="2">template&lt;typename ReducingFnT , typename StateT , typename... InputTs&gt; </td></tr>
<tr class="memitem:a2da0bbda0517148bb5c7a784235bf88c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a2da0bbda0517148bb5c7a784235bf88c">call</a> (ReducingFnT &amp;&amp;step, StateT &amp;&amp;state, InputTs &amp;&amp;...ins) -&gt; <a class="el" href="namespaceatria_1_1estd.html#a3d7e0f60f8c349b2a05f1fcf56750360">estd::enable_if_t</a>&lt; <a class="el" href="structatria_1_1xform_1_1is__skip__state.html">is_skip_state</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; StateT &gt; &gt;</td></tr>
<tr class="memdesc:a2da0bbda0517148bb5c7a784235bf88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the next reducing function in a transducer that could otherwise skip calling the next reducing function.  <a href="#a2da0bbda0517148bb5c7a784235bf88c">More...</a><br /></td></tr>
<tr class="separator:a2da0bbda0517148bb5c7a784235bf88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742ad6e9cabc139c89bf66d8dc78c9ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a742ad6e9cabc139c89bf66d8dc78c9ca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a742ad6e9cabc139c89bf66d8dc78c9ca">state_complete</a> (T &amp;&amp;s) -&gt; decltype(<a class="el" href="structatria_1_1xform_1_1state__traits.html">state_traits_t</a>&lt; T &gt;::complete(std::forward&lt; T &gt;(s)))</td></tr>
<tr class="memdesc:a742ad6e9cabc139c89bf66d8dc78c9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for calling <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#a18456c946a84c9b57eb4e0bd2732024a" title="Unwraps all the layers of state wrappers returning the deepmost. ">state_traits::complete</a></code>  <a href="#a742ad6e9cabc139c89bf66d8dc78c9ca">More...</a><br /></td></tr>
<tr class="separator:a742ad6e9cabc139c89bf66d8dc78c9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bd5ac59b27e0db927043add4734650"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3bd5ac59b27e0db927043add4734650"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#aa3bd5ac59b27e0db927043add4734650">state_is_reduced</a> (T &amp;&amp;s) -&gt; bool</td></tr>
<tr class="memdesc:aa3bd5ac59b27e0db927043add4734650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for calling <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#a90d4465e97d7fd11c872c25e5ad13ce4" title="Returns whether the value is idempotent, and thus, the reduction can finish. ">state_traits::is_reduced</a></code>  <a href="#aa3bd5ac59b27e0db927043add4734650">More...</a><br /></td></tr>
<tr class="separator:aa3bd5ac59b27e0db927043add4734650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583e716efb1c0c996c31fa249ba1f7fe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename D &gt; </td></tr>
<tr class="memitem:a583e716efb1c0c996c31fa249ba1f7fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a583e716efb1c0c996c31fa249ba1f7fe">state_data</a> (T &amp;&amp;s, D &amp;&amp;d) -&gt; decltype(<a class="el" href="structatria_1_1xform_1_1state__traits.html">state_traits_t</a>&lt; T &gt;::data(std::forward&lt; T &gt;(s), std::forward&lt; D &gt;(d)))</td></tr>
<tr class="memdesc:a583e716efb1c0c996c31fa249ba1f7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for calling <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#ac09e5ef6d0902f21a633c3b7105e95ef" title="Returns the associated from the current state. ">state_traits::data</a></code>  <a href="#a583e716efb1c0c996c31fa249ba1f7fe">More...</a><br /></td></tr>
<tr class="separator:a583e716efb1c0c996c31fa249ba1f7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3d5f97c45a219e65ba34cd3838e7ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f3d5f97c45a219e65ba34cd3838e7ed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a8f3d5f97c45a219e65ba34cd3838e7ed">state_unwrap</a> (T &amp;&amp;s) -&gt; decltype(<a class="el" href="structatria_1_1xform_1_1state__traits.html">state_traits_t</a>&lt; T &gt;::unwrap(std::forward&lt; T &gt;(s)))</td></tr>
<tr class="memdesc:a8f3d5f97c45a219e65ba34cd3838e7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for calling <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#a7a61e1d47a98a6262eeb5d3c1dc17a89" title="Unwraps this layers of state wrappers, returning the nested state for the next reducing function...">state_traits::unwrap</a></code>  <a href="#a8f3d5f97c45a219e65ba34cd3838e7ed">More...</a><br /></td></tr>
<tr class="separator:a8f3d5f97c45a219e65ba34cd3838e7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae241d09b36ebe81badd419120047f7ab"><td class="memTemplParams" colspan="2">template&lt;typename TagT  = no_tag, typename StateT , typename DataT  = TagT&gt; </td></tr>
<tr class="memitem:ae241d09b36ebe81badd419120047f7ab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#ae241d09b36ebe81badd419120047f7ab">wrap_state</a> (StateT &amp;&amp;next, DataT &amp;&amp;data=DataT{}) -&gt; <a class="el" href="structatria_1_1xform_1_1state__wrapper.html">state_wrapper</a>&lt; TagT, <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; StateT &gt;, <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; DataT &gt; &gt;</td></tr>
<tr class="memdesc:ae241d09b36ebe81badd419120047f7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tag <code>TagT</code> and a state <code>next</code> and associated <code>data</code>, returns a <code><a class="el" href="structatria_1_1xform_1_1state__wrapper.html" title="A decorator for the accumulator of a reduction. ">state_wrapper</a></code> instance.  <a href="#ae241d09b36ebe81badd419120047f7ab">More...</a><br /></td></tr>
<tr class="separator:ae241d09b36ebe81badd419120047f7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2b263b3e03295e68676c7df069f328"><td class="memTemplParams" colspan="2">template&lt;typename TagT , typename T &gt; </td></tr>
<tr class="memitem:a0e2b263b3e03295e68676c7df069f328"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a0e2b263b3e03295e68676c7df069f328">state_wrapper_complete</a> (TagT, T &amp;&amp;s) -&gt; decltype(<a class="el" href="namespaceatria_1_1xform.html#a742ad6e9cabc139c89bf66d8dc78c9ca">state_complete</a>(<a class="el" href="namespaceatria_1_1xform.html#a8f3d5f97c45a219e65ba34cd3838e7ed">state_unwrap</a>(std::forward&lt; T &gt;(s))))</td></tr>
<tr class="memdesc:a0e2b263b3e03295e68676c7df069f328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for easy overloading of <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#a18456c946a84c9b57eb4e0bd2732024a" title="Unwraps all the layers of state wrappers returning the deepmost. ">state_traits::complete</a></code> for state wrappers with a specific tag.  <a href="#a0e2b263b3e03295e68676c7df069f328">More...</a><br /></td></tr>
<tr class="separator:a0e2b263b3e03295e68676c7df069f328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1356003e10762cec1b6e68b4676ee8"><td class="memTemplParams" colspan="2">template&lt;typename TagT , typename T &gt; </td></tr>
<tr class="memitem:a0a1356003e10762cec1b6e68b4676ee8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a0a1356003e10762cec1b6e68b4676ee8">state_wrapper_unwrap</a> (TagT, T &amp;&amp;s) -&gt; decltype(std::get&lt; 0 &gt;(std::forward&lt; T &gt;(s)))</td></tr>
<tr class="memdesc:a0a1356003e10762cec1b6e68b4676ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for easy overloading of <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#a7a61e1d47a98a6262eeb5d3c1dc17a89" title="Unwraps this layers of state wrappers, returning the nested state for the next reducing function...">state_traits::unwrap</a></code> for state wrappers with a specific tag.  <a href="#a0a1356003e10762cec1b6e68b4676ee8">More...</a><br /></td></tr>
<tr class="separator:a0a1356003e10762cec1b6e68b4676ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8100207fd3c7ddf71e629248b76a184b"><td class="memTemplParams" colspan="2">template&lt;typename TagT , typename T , typename D &gt; </td></tr>
<tr class="memitem:a8100207fd3c7ddf71e629248b76a184b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a8100207fd3c7ddf71e629248b76a184b">state_wrapper_data</a> (TagT tag, T &amp;&amp;s, D &amp;&amp;) -&gt; decltype(state_wrapper_data(tag, std::forward&lt; T &gt;(s)))</td></tr>
<tr class="memdesc:a8100207fd3c7ddf71e629248b76a184b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for easy overloading of <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#ac09e5ef6d0902f21a633c3b7105e95ef" title="Returns the associated from the current state. ">state_traits::data</a></code> for state wrappers with a specific tag.  <a href="#a8100207fd3c7ddf71e629248b76a184b">More...</a><br /></td></tr>
<tr class="separator:a8100207fd3c7ddf71e629248b76a184b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26f2cf1de8c03cc6c6b505ba18f18a7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa26f2cf1de8c03cc6c6b505ba18f18a7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa26f2cf1de8c03cc6c6b505ba18f18a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>state_wrapper_data</b> (T &amp;&amp;s) -&gt; decltype(state_wrapper_data(typename <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; T &gt;::tag</td></tr>
<tr class="separator:aa26f2cf1de8c03cc6c6b505ba18f18a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9251df10c6ada4d4482d215cf997c67"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad9251df10c6ada4d4482d215cf997c67"></a>
template&lt;typename TagT , typename T &gt; </td></tr>
<tr class="memitem:ad9251df10c6ada4d4482d215cf997c67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>state_wrapper_data</b> (TagT, T &amp;&amp;s) -&gt; decltype(std::get&lt; 1 &gt;(std::forward&lt; T &gt;(s)))</td></tr>
<tr class="separator:ad9251df10c6ada4d4482d215cf997c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74cc4a347fd2ad83c01a0c7c35292de"><td class="memTemplParams" colspan="2">template&lt;typename TagT , typename DataT &gt; </td></tr>
<tr class="memitem:af74cc4a347fd2ad83c01a0c7c35292de"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#af74cc4a347fd2ad83c01a0c7c35292de">state_wrapper_data_is_reduced</a> (TagT, DataT &amp;&amp;)</td></tr>
<tr class="memdesc:af74cc4a347fd2ad83c01a0c7c35292de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns whether the <code>DataT</code> associated with a state wrapper with tag <code>TagT</code> is reduced &ndash; i.e.  <a href="#af74cc4a347fd2ad83c01a0c7c35292de">More...</a><br /></td></tr>
<tr class="separator:af74cc4a347fd2ad83c01a0c7c35292de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2250f9477d337be124b73f3ad9d2c8"><td class="memTemplParams" colspan="2">template&lt;typename TagT , typename T &gt; </td></tr>
<tr class="memitem:aab2250f9477d337be124b73f3ad9d2c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#aab2250f9477d337be124b73f3ad9d2c8">state_wrapper_is_reduced</a> (TagT tag, T &amp;&amp;s)</td></tr>
<tr class="memdesc:aab2250f9477d337be124b73f3ad9d2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for easy overloading of <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#a90d4465e97d7fd11c872c25e5ad13ce4" title="Returns whether the value is idempotent, and thus, the reduction can finish. ">state_traits::is_reduced</a></code> for state wrappers with a specific tag.  <a href="#aab2250f9477d337be124b73f3ad9d2c8">More...</a><br /></td></tr>
<tr class="separator:aab2250f9477d337be124b73f3ad9d2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ddac4a321b0ab20393f47485e42a50"><td class="memTemplParams" colspan="2">template&lt;typename XformT , typename ReducingFnT , typename StateT , typename... InputRangeTs&gt; </td></tr>
<tr class="memitem:aa3ddac4a321b0ab20393f47485e42a50"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#aa3ddac4a321b0ab20393f47485e42a50">transduce</a> (XformT &amp;&amp;xform, ReducingFnT &amp;&amp;step, StateT &amp;&amp;state, InputRangeTs &amp;&amp;...ranges) -&gt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; StateT &gt;</td></tr>
<tr class="memdesc:aa3ddac4a321b0ab20393f47485e42a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/transduce.  <a href="#aa3ddac4a321b0ab20393f47485e42a50">More...</a><br /></td></tr>
<tr class="separator:aa3ddac4a321b0ab20393f47485e42a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18c36bdd6e85b3a7f6584603386ec61"><td class="memTemplParams" colspan="2">template&lt;typename InputRangeT &gt; </td></tr>
<tr class="memitem:ad18c36bdd6e85b3a7f6584603386ec61"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#ad18c36bdd6e85b3a7f6584603386ec61">chainr</a> (InputRangeT &amp;&amp;r) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">chainr_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; InputRangeT &gt; &gt;</td></tr>
<tr class="memdesc:ad18c36bdd6e85b3a7f6584603386ec61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducer produces the sequence passed as parameter after all other input has finished.  <a href="#ad18c36bdd6e85b3a7f6584603386ec61">More...</a><br /></td></tr>
<tr class="separator:ad18c36bdd6e85b3a7f6584603386ec61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f33bc458b6660c40fd34547163592d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a94f33bc458b6660c40fd34547163592d"></a>
template&lt;typename InputRangeT , typename... InputRangeTs&gt; </td></tr>
<tr class="memitem:a94f33bc458b6660c40fd34547163592d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chainr</b> (InputRangeT &amp;&amp;r, InputRangeTs &amp;&amp;...rs) -&gt; decltype(comp(chainr(std::forward&lt; InputRangeT &gt;(r)), chainr(std::forward&lt; InputRangeTs &gt;(rs))...))</td></tr>
<tr class="separator:a94f33bc458b6660c40fd34547163592d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b85e8714c0aa88ddb6dcc59c3501e6"><td class="memTemplParams" colspan="2">template&lt;typename... InputRangeTs&gt; </td></tr>
<tr class="memitem:ac2b85e8714c0aa88ddb6dcc59c3501e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#ac2b85e8714c0aa88ddb6dcc59c3501e6">chain</a> (InputRangeTs &amp;&amp;...rs) -&gt; decltype(<a class="el" href="namespaceatria_1_1xform.html#ad18c36bdd6e85b3a7f6584603386ec61">chainr</a>(std::forward&lt; InputRangeTs &gt;(rs)...))</td></tr>
<tr class="memdesc:ac2b85e8714c0aa88ddb6dcc59c3501e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>chainr</code>  <a href="#ac2b85e8714c0aa88ddb6dcc59c3501e6">More...</a><br /></td></tr>
<tr class="separator:ac2b85e8714c0aa88ddb6dcc59c3501e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d85a17047adedbda1892ac046e092d"><td class="memTemplParams" colspan="2">template&lt;typename InputRangeT &gt; </td></tr>
<tr class="memitem:a70d85a17047adedbda1892ac046e092d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a70d85a17047adedbda1892ac046e092d">chainl</a> (InputRangeT &amp;&amp;r) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">chainl_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; InputRangeT &gt; &gt;</td></tr>
<tr class="memdesc:a70d85a17047adedbda1892ac046e092d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducer produces the sequence passed as parameter before processing the first input.  <a href="#a70d85a17047adedbda1892ac046e092d">More...</a><br /></td></tr>
<tr class="separator:a70d85a17047adedbda1892ac046e092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3193b85feafd812adb196cf4efef3a96"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3193b85feafd812adb196cf4efef3a96"></a>
template&lt;typename InputRangeT , typename... InputRangeTs&gt; </td></tr>
<tr class="memitem:a3193b85feafd812adb196cf4efef3a96"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chainl</b> (InputRangeT &amp;&amp;r, InputRangeTs &amp;&amp;...rs) -&gt; decltype(comp(chainl(std::forward&lt; InputRangeT &gt;(r)), chainl(std::forward&lt; InputRangeTs &gt;(rs))...))</td></tr>
<tr class="separator:a3193b85feafd812adb196cf4efef3a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355c4a75a7b2d4a537ef915446b4e307"><td class="memTemplParams" colspan="2">template&lt;typename InitT  = std::size_t, typename StepT  = InitT&gt; </td></tr>
<tr class="memitem:a355c4a75a7b2d4a537ef915446b4e307"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a355c4a75a7b2d4a537ef915446b4e307">count</a> (InitT init=InitT{0}, StepT step=StepT{1}) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">count_t</a>&lt; InitT, StepT &gt;</td></tr>
<tr class="memdesc:a355c4a75a7b2d4a537ef915446b4e307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator transducer produces a sequence:  <a href="#a355c4a75a7b2d4a537ef915446b4e307">More...</a><br /></td></tr>
<tr class="separator:a355c4a75a7b2d4a537ef915446b4e307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca64e4188beed34b52a9ddc7e692bd5"><td class="memTemplParams" colspan="2">template&lt;typename InputRangeT &gt; </td></tr>
<tr class="memitem:a6ca64e4188beed34b52a9ddc7e692bd5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a6ca64e4188beed34b52a9ddc7e692bd5">cycle</a> (InputRangeT &amp;&amp;r) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">cycle_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; InputRangeT &gt; &gt;</td></tr>
<tr class="memdesc:a6ca64e4188beed34b52a9ddc7e692bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator transducer produces the sequence passed as parameter, by cycleating over it.  <a href="#a6ca64e4188beed34b52a9ddc7e692bd5">More...</a><br /></td></tr>
<tr class="separator:a6ca64e4188beed34b52a9ddc7e692bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a2ed4b0d5e43bc646442980a64dfae"><td class="memTemplParams" colspan="2"><a class="anchor" id="a33a2ed4b0d5e43bc646442980a64dfae"></a>
template&lt;typename InputRangeT , typename... InputRangeTs&gt; </td></tr>
<tr class="memitem:a33a2ed4b0d5e43bc646442980a64dfae"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cycle</b> (InputRangeT &amp;&amp;r, InputRangeTs &amp;&amp;...rs) -&gt; decltype(comp(cycle(std::forward&lt; InputRangeT &gt;(r)), cycle(std::forward&lt; InputRangeTs &gt;(rs))...))</td></tr>
<tr class="separator:a33a2ed4b0d5e43bc646442980a64dfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f108701be19ec8d379b9f6b0515e53"><td class="memTemplParams" colspan="2">template&lt;typename IntegralT &gt; </td></tr>
<tr class="memitem:a01f108701be19ec8d379b9f6b0515e53"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a01f108701be19ec8d379b9f6b0515e53">drop</a> (IntegralT &amp;&amp;n) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">drop_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; IntegralT &gt; &gt;</td></tr>
<tr class="memdesc:a01f108701be19ec8d379b9f6b0515e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/drop$1.  <a href="#a01f108701be19ec8d379b9f6b0515e53">More...</a><br /></td></tr>
<tr class="separator:a01f108701be19ec8d379b9f6b0515e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38696dd462d8382acbb53035db399d75"><td class="memTemplParams" colspan="2">template&lt;typename PredicateT &gt; </td></tr>
<tr class="memitem:a38696dd462d8382acbb53035db399d75"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a38696dd462d8382acbb53035db399d75">drop_while</a> (PredicateT &amp;&amp;n) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">drop_while_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; PredicateT &gt; &gt;</td></tr>
<tr class="memdesc:a38696dd462d8382acbb53035db399d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/drop_while$1.  <a href="#a38696dd462d8382acbb53035db399d75">More...</a><br /></td></tr>
<tr class="separator:a38696dd462d8382acbb53035db399d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a075d51b9bc7bda8f0b27de56d38c33"><td class="memTemplParams" colspan="2">template&lt;typename IntegralT &gt; </td></tr>
<tr class="memitem:a8a075d51b9bc7bda8f0b27de56d38c33"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a8a075d51b9bc7bda8f0b27de56d38c33">enumerate_from</a> (IntegralT &amp;&amp;init) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">enumerate_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; IntegralT &gt; &gt;</td></tr>
<tr class="memdesc:a8a075d51b9bc7bda8f0b27de56d38c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducer that given a sequence:  <a href="#a8a075d51b9bc7bda8f0b27de56d38c33">More...</a><br /></td></tr>
<tr class="separator:a8a075d51b9bc7bda8f0b27de56d38c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ba27e99da8878464eb743b464c368e"><td class="memTemplParams" colspan="2">template&lt;typename PredicateT &gt; </td></tr>
<tr class="memitem:a80ba27e99da8878464eb743b464c368e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a80ba27e99da8878464eb743b464c368e">filter</a> (PredicateT &amp;&amp;predicate) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">filter_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; PredicateT &gt; &gt;</td></tr>
<tr class="memdesc:a80ba27e99da8878464eb743b464c368e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/filter$1.  <a href="#a80ba27e99da8878464eb743b464c368e">More...</a><br /></td></tr>
<tr class="separator:a80ba27e99da8878464eb743b464c368e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88287d69938c5ac4fb74dbbbe985a449"><td class="memTemplParams" colspan="2">template&lt;typename... ValueTs&gt; </td></tr>
<tr class="memitem:a88287d69938c5ac4fb74dbbbe985a449"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a88287d69938c5ac4fb74dbbbe985a449">interpose</a> (ValueTs &amp;&amp;...xs) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">interpose_t</a>&lt; estd::make_index_sequence&lt; sizeof...(ValueTs)&gt;, std::tuple&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; ValueTs &gt;...&gt; &gt;</td></tr>
<tr class="memdesc:a88287d69938c5ac4fb74dbbbe985a449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like clojure.core/interpose$1.  <a href="#a88287d69938c5ac4fb74dbbbe985a449">More...</a><br /></td></tr>
<tr class="separator:a88287d69938c5ac4fb74dbbbe985a449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfab0c45a5f548e9a839f2060a45da77"><td class="memTemplParams" colspan="2">template&lt;typename InputRangeT &gt; </td></tr>
<tr class="memitem:acfab0c45a5f548e9a839f2060a45da77"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#acfab0c45a5f548e9a839f2060a45da77">iter</a> (InputRangeT &amp;&amp;r) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">iter_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; InputRangeT &gt; &gt;</td></tr>
<tr class="memdesc:acfab0c45a5f548e9a839f2060a45da77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator transducer produces the sequence passed as parameter, by iterating over it.  <a href="#acfab0c45a5f548e9a839f2060a45da77">More...</a><br /></td></tr>
<tr class="separator:acfab0c45a5f548e9a839f2060a45da77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a57078710911f202798fa9771fd0f9c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0a57078710911f202798fa9771fd0f9c"></a>
template&lt;typename InputRangeT , typename... InputRangeTs&gt; </td></tr>
<tr class="memitem:a0a57078710911f202798fa9771fd0f9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iter</b> (InputRangeT &amp;&amp;r, InputRangeTs &amp;&amp;...rs) -&gt; decltype(comp(iter(std::forward&lt; InputRangeT &gt;(r)), iter(std::forward&lt; InputRangeTs &gt;(rs))...))</td></tr>
<tr class="separator:a0a57078710911f202798fa9771fd0f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5d15acc0898885bc4386a7c9b41005"><td class="memTemplParams" colspan="2">template&lt;typename MappingT &gt; </td></tr>
<tr class="memitem:a9f5d15acc0898885bc4386a7c9b41005"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a> (MappingT &amp;&amp;mapping) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">map_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; MappingT &gt; &gt;</td></tr>
<tr class="memdesc:a9f5d15acc0898885bc4386a7c9b41005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/map$1.  <a href="#a9f5d15acc0898885bc4386a7c9b41005">More...</a><br /></td></tr>
<tr class="separator:a9f5d15acc0898885bc4386a7c9b41005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ac827e3b48e237ef49846ab4336e61"><td class="memTemplParams" colspan="2">template&lt;typename MappingT &gt; </td></tr>
<tr class="memitem:a84ac827e3b48e237ef49846ab4336e61"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a84ac827e3b48e237ef49846ab4336e61">map_indexed</a> (MappingT &amp;&amp;mapping) -&gt; decltype(comp(<a class="el" href="namespaceatria_1_1xform.html#a355c4a75a7b2d4a537ef915446b4e307">count</a>(), <a class="el" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>(std::forward&lt; MappingT &gt;(mapping))))</td></tr>
<tr class="memdesc:a84ac827e3b48e237ef49846ab4336e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/map-indexed$1.  <a href="#a84ac827e3b48e237ef49846ab4336e61">More...</a><br /></td></tr>
<tr class="separator:a84ac827e3b48e237ef49846ab4336e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7934b802ca1cdc1dbd693ab99e908611"><td class="memTemplParams" colspan="2">template&lt;typename MappingT &gt; </td></tr>
<tr class="memitem:a7934b802ca1cdc1dbd693ab99e908611"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a7934b802ca1cdc1dbd693ab99e908611">mapcat</a> (MappingT &amp;&amp;mapping) -&gt; decltype(comp(<a class="el" href="namespaceatria_1_1xform.html#a7b3db0b1325b015399b0d50f75e33220">cat</a>, <a class="el" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>(std::forward&lt; MappingT &gt;(mapping))))</td></tr>
<tr class="memdesc:a7934b802ca1cdc1dbd693ab99e908611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/mapcat$1.  <a href="#a7934b802ca1cdc1dbd693ab99e908611">More...</a><br /></td></tr>
<tr class="separator:a7934b802ca1cdc1dbd693ab99e908611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83103216261e92d2147ce41252272f76"><td class="memTemplParams" colspan="2">template&lt;typename IntegralT &gt; </td></tr>
<tr class="memitem:a83103216261e92d2147ce41252272f76"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a83103216261e92d2147ce41252272f76">partition</a> (IntegralT &amp;&amp;n) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">partition_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; IntegralT &gt; &gt;</td></tr>
<tr class="memdesc:a83103216261e92d2147ce41252272f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/partition-all$1.  <a href="#a83103216261e92d2147ce41252272f76">More...</a><br /></td></tr>
<tr class="separator:a83103216261e92d2147ce41252272f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e3ff42b7cdfce00041ef5be8c89efc"><td class="memTemplParams" colspan="2">template&lt;typename MappingT &gt; </td></tr>
<tr class="memitem:a89e3ff42b7cdfce00041ef5be8c89efc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a89e3ff42b7cdfce00041ef5be8c89efc">partition_by</a> (MappingT &amp;&amp;mapping) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">partition_by_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; MappingT &gt; &gt;</td></tr>
<tr class="memdesc:a89e3ff42b7cdfce00041ef5be8c89efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/partition-by$1.  <a href="#a89e3ff42b7cdfce00041ef5be8c89efc">More...</a><br /></td></tr>
<tr class="separator:a89e3ff42b7cdfce00041ef5be8c89efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa098e18370e4117e3ae707e280d2bb"><td class="memTemplParams" colspan="2">template&lt;typename InputRangeT &gt; </td></tr>
<tr class="memitem:a4fa098e18370e4117e3ae707e280d2bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a4fa098e18370e4117e3ae707e280d2bb">product</a> (InputRangeT &amp;&amp;r) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">product_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; InputRangeT &gt; &gt;</td></tr>
<tr class="memdesc:a4fa098e18370e4117e3ae707e280d2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducer combines every element that passes by with every element in the sequence that it takes as arguemnt.  <a href="#a4fa098e18370e4117e3ae707e280d2bb">More...</a><br /></td></tr>
<tr class="separator:a4fa098e18370e4117e3ae707e280d2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d99de31d876dfda50bb4d6399763910"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d99de31d876dfda50bb4d6399763910"></a>
template&lt;typename InputRangeT , typename... InputRangeTs&gt; </td></tr>
<tr class="memitem:a8d99de31d876dfda50bb4d6399763910"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>product</b> (InputRangeT &amp;&amp;r, InputRangeTs &amp;&amp;...rs) -&gt; decltype(comp(product(std::forward&lt; InputRangeT &gt;(r)), product(std::forward&lt; InputRangeTs &gt;(rs))...))</td></tr>
<tr class="separator:a8d99de31d876dfda50bb4d6399763910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6065c740d69641dc343d90814152b0"><td class="memTemplParams" colspan="2">template&lt;typename ProbabilityT , typename GeneratorT  = detail::default_generator&gt; </td></tr>
<tr class="memitem:abb6065c740d69641dc343d90814152b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#abb6065c740d69641dc343d90814152b0">random_sample</a> (ProbabilityT prob, GeneratorT generator=GeneratorT{}) -&gt; decltype(<a class="el" href="namespaceatria_1_1xform.html#a80ba27e99da8878464eb743b464c368e">filter</a>(detail::random_sampler&lt; ProbabilityT, GeneratorT &gt;</td></tr>
<tr class="memdesc:abb6065c740d69641dc343d90814152b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/random-sample$1.  <a href="#abb6065c740d69641dc343d90814152b0">More...</a><br /></td></tr>
<tr class="separator:abb6065c740d69641dc343d90814152b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e7c541dfbe38806edd2ddab4c6975b"><td class="memTemplParams" colspan="2">template&lt;typename StopT &gt; </td></tr>
<tr class="memitem:a08e7c541dfbe38806edd2ddab4c6975b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a08e7c541dfbe38806edd2ddab4c6975b">range</a> (StopT &amp;&amp;stop) -&gt; decltype(comp(<a class="el" href="namespaceatria_1_1xform.html#a355c4a75a7b2d4a537ef915446b4e307">count</a>(), <a class="el" href="namespaceatria_1_1xform.html#ad1392e213eac822dbbb8500608012bb4">take</a>(std::forward&lt; StopT &gt;(stop))))</td></tr>
<tr class="memdesc:a08e7c541dfbe38806edd2ddab4c6975b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator transducer version of Python <code>range</code>  <a href="#a08e7c541dfbe38806edd2ddab4c6975b">More...</a><br /></td></tr>
<tr class="separator:a08e7c541dfbe38806edd2ddab4c6975b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc87987728655b68f94fa1879ac6738b"><td class="memTemplParams" colspan="2"><a class="anchor" id="abc87987728655b68f94fa1879ac6738b"></a>
template&lt;typename StartT , typename StopT &gt; </td></tr>
<tr class="memitem:abc87987728655b68f94fa1879ac6738b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>range</b> (StartT &amp;&amp;start, StopT &amp;&amp;stop) -&gt; decltype(comp(<a class="el" href="namespaceatria_1_1xform.html#a355c4a75a7b2d4a537ef915446b4e307">count</a>(start), <a class="el" href="namespaceatria_1_1xform.html#ad1392e213eac822dbbb8500608012bb4">take</a>(std::max(decltype(stop-start)</td></tr>
<tr class="separator:abc87987728655b68f94fa1879ac6738b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a13360753f1863fbcc94c877ad6091a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2a13360753f1863fbcc94c877ad6091a"></a>
template&lt;typename StartT , typename StopT , typename StepT &gt; </td></tr>
<tr class="memitem:a2a13360753f1863fbcc94c877ad6091a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>range</b> (StartT &amp;&amp;start, StopT &amp;&amp;stop, StepT &amp;&amp;step) -&gt; decltype(comp(<a class="el" href="namespaceatria_1_1xform.html#a355c4a75a7b2d4a537ef915446b4e307">count</a>(start, step), <a class="el" href="namespaceatria_1_1xform.html#ad1392e213eac822dbbb8500608012bb4">take</a>(std::max(decltype((stop-start)/step)</td></tr>
<tr class="separator:a2a13360753f1863fbcc94c877ad6091a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6801522a4749259f1da08257065abc3"><td class="memTemplParams" colspan="2">template&lt;typename PredicateT &gt; </td></tr>
<tr class="memitem:ad6801522a4749259f1da08257065abc3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#ad6801522a4749259f1da08257065abc3">remove</a> (PredicateT &amp;&amp;pred) -&gt; decltype(<a class="el" href="namespaceatria_1_1xform.html#a80ba27e99da8878464eb743b464c368e">filter</a>(complement(std::forward&lt; PredicateT &gt;(pred))))</td></tr>
<tr class="memdesc:ad6801522a4749259f1da08257065abc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/remove$1.  <a href="#ad6801522a4749259f1da08257065abc3">More...</a><br /></td></tr>
<tr class="separator:ad6801522a4749259f1da08257065abc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93215c74409bd3b594605eaa624d4d18"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a93215c74409bd3b594605eaa624d4d18"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a93215c74409bd3b594605eaa624d4d18">repeat</a> (ValueT &amp;&amp;r) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">repeat_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; ValueT &gt; &gt;</td></tr>
<tr class="memdesc:a93215c74409bd3b594605eaa624d4d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator transducer produces the values passed as parameter infinitely.  <a href="#a93215c74409bd3b594605eaa624d4d18">More...</a><br /></td></tr>
<tr class="separator:a93215c74409bd3b594605eaa624d4d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3110bab95ca24d94cd98d3fa2e619ea1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3110bab95ca24d94cd98d3fa2e619ea1"></a>
template&lt;typename ValueT , typename... ValueTs&gt; </td></tr>
<tr class="memitem:a3110bab95ca24d94cd98d3fa2e619ea1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>repeat</b> (ValueT &amp;&amp;r, ValueTs &amp;&amp;...rs) -&gt; decltype(comp(repeat(std::forward&lt; ValueT &gt;(r)), repeat(std::forward&lt; ValueTs &gt;(rs))...))</td></tr>
<tr class="separator:a3110bab95ca24d94cd98d3fa2e619ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4654f2db5983fae5b5413baf5048bc9d"><td class="memTemplParams" colspan="2">template&lt;typename IntegralT , typename... ValueTs&gt; </td></tr>
<tr class="memitem:a4654f2db5983fae5b5413baf5048bc9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a4654f2db5983fae5b5413baf5048bc9d">repeatn</a> (IntegralT &amp;&amp;n, ValueTs &amp;&amp;...rs) -&gt; decltype(comp(<a class="el" href="namespaceatria_1_1xform.html#a93215c74409bd3b594605eaa624d4d18">repeat</a>(std::forward&lt; ValueTs &gt;(rs)...), <a class="el" href="namespaceatria_1_1xform.html#ad1392e213eac822dbbb8500608012bb4">take</a>(std::forward&lt; IntegralT &gt;(n))))</td></tr>
<tr class="memdesc:a4654f2db5983fae5b5413baf5048bc9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator transducer produces the values passed as parameter up to <code>n</code> times.  <a href="#a4654f2db5983fae5b5413baf5048bc9d">More...</a><br /></td></tr>
<tr class="separator:a4654f2db5983fae5b5413baf5048bc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04b4d4796efe53d507356cb40d10ea0"><td class="memTemplParams" colspan="2">template&lt;typename TableT &gt; </td></tr>
<tr class="memitem:aa04b4d4796efe53d507356cb40d10ea0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#aa04b4d4796efe53d507356cb40d10ea0">replace</a> (TableT &amp;&amp;table) -&gt; decltype(<a class="el" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>(detail::lookup_or_key&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; TableT &gt; &gt;</td></tr>
<tr class="memdesc:aa04b4d4796efe53d507356cb40d10ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/replace$1.  <a href="#aa04b4d4796efe53d507356cb40d10ea0">More...</a><br /></td></tr>
<tr class="separator:aa04b4d4796efe53d507356cb40d10ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34877a89c42bfdf11a53c7218f71302"><td class="memTemplParams" colspan="2">template&lt;typename TableT &gt; </td></tr>
<tr class="memitem:af34877a89c42bfdf11a53c7218f71302"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#af34877a89c42bfdf11a53c7218f71302">replace_all</a> (TableT &amp;&amp;table) -&gt; decltype(<a class="el" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>(detail::lookup_default&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; TableT &gt; &gt;</td></tr>
<tr class="memdesc:af34877a89c42bfdf11a53c7218f71302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducer that replaces all elements by <code>table[tuplify(inputs)]</code>  <a href="#af34877a89c42bfdf11a53c7218f71302">More...</a><br /></td></tr>
<tr class="separator:af34877a89c42bfdf11a53c7218f71302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad19ba27a1533eb710ce84f9c300915"><td class="memTemplParams" colspan="2">template&lt;typename TableT &gt; </td></tr>
<tr class="memitem:aaad19ba27a1533eb710ce84f9c300915"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#aaad19ba27a1533eb710ce84f9c300915">replace_all_safe</a> (TableT &amp;&amp;table) -&gt; decltype(<a class="el" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>(detail::lookup_safe&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; TableT &gt; &gt;</td></tr>
<tr class="memdesc:aaad19ba27a1533eb710ce84f9c300915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducer that replaces all elements by <code>table.at(tuplify(inputs))</code>  <a href="#aaad19ba27a1533eb710ce84f9c300915">More...</a><br /></td></tr>
<tr class="separator:aaad19ba27a1533eb710ce84f9c300915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1392e213eac822dbbb8500608012bb4"><td class="memTemplParams" colspan="2">template&lt;typename IntegralT &gt; </td></tr>
<tr class="memitem:ad1392e213eac822dbbb8500608012bb4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#ad1392e213eac822dbbb8500608012bb4">take</a> (IntegralT &amp;&amp;n) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">take_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; IntegralT &gt; &gt;</td></tr>
<tr class="memdesc:ad1392e213eac822dbbb8500608012bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/take$1.  <a href="#ad1392e213eac822dbbb8500608012bb4">More...</a><br /></td></tr>
<tr class="separator:ad1392e213eac822dbbb8500608012bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17787884a59f85db0f31190809a9de80"><td class="memTemplParams" colspan="2">template&lt;typename IntegralT &gt; </td></tr>
<tr class="memitem:a17787884a59f85db0f31190809a9de80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a17787884a59f85db0f31190809a9de80">take_nth</a> (IntegralT &amp;&amp;n) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">take_nth_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; IntegralT &gt; &gt;</td></tr>
<tr class="memdesc:a17787884a59f85db0f31190809a9de80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/take_nth$1.  <a href="#a17787884a59f85db0f31190809a9de80">More...</a><br /></td></tr>
<tr class="separator:a17787884a59f85db0f31190809a9de80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68949f8b8b3369cd89c0f5e522b762c2"><td class="memTemplParams" colspan="2">template&lt;typename PredicateT &gt; </td></tr>
<tr class="memitem:a68949f8b8b3369cd89c0f5e522b762c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a68949f8b8b3369cd89c0f5e522b762c2">take_while</a> (PredicateT &amp;&amp;p) -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">take_while_t</a>&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; PredicateT &gt; &gt;</td></tr>
<tr class="memdesc:a68949f8b8b3369cd89c0f5e522b762c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/take_while$1.  <a href="#a68949f8b8b3369cd89c0f5e522b762c2">More...</a><br /></td></tr>
<tr class="separator:a68949f8b8b3369cd89c0f5e522b762c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5626f067144894d8ba89075c02120a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a1c5626f067144894d8ba89075c02120a">traced</a> (std::string message) -&gt; decltype(<a class="el" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>(tracer</td></tr>
<tr class="memdesc:a1c5626f067144894d8ba89075c02120a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducer that traces the values values that pass through it and forwards them forward in the chain.  <a href="#a1c5626f067144894d8ba89075c02120a">More...</a><br /></td></tr>
<tr class="separator:a1c5626f067144894d8ba89075c02120a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4a7505add816a4798fcb3cc96c7e7d"><td class="memTemplParams" colspan="2">template&lt;typename StateT , typename UnwrappedFn , typename WrappedFn &gt; </td></tr>
<tr class="memitem:ade4a7505add816a4798fcb3cc96c7e7d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#ade4a7505add816a4798fcb3cc96c7e7d">with_state</a> (StateT &amp;&amp;st, UnwrappedFn &amp;&amp;, WrappedFn &amp;&amp;fn) -&gt; meta::lazy_enable_if_t&lt; !std::is_same&lt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; StateT &gt;, <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt; decltype(<a class="el" href="namespaceatria_1_1xform.html#a742ad6e9cabc139c89bf66d8dc78c9ca">state_complete</a>(st))&gt; &gt;::value, std::result_of&lt; WrappedFn(StateT)&gt; &gt;</td></tr>
<tr class="memdesc:ade4a7505add816a4798fcb3cc96c7e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a value <code>st</code> that represents the state of a reduction, this function generically dispatches to the right function <code>UnwrappedFn</code> or <code>WrappedFn</code>, depending of whether the value is already wrapped or not.  <a href="#ade4a7505add816a4798fcb3cc96c7e7d">More...</a><br /></td></tr>
<tr class="separator:ade4a7505add816a4798fcb3cc96c7e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae1eca5df73970c88fd79ae7bdc7d2f51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1eca5df73970c88fd79ae7bdc7d2f51"></a>
constexpr struct <a class="el" href="structatria_1_1xform_1_1emplace__back__rf__t.html">atria::xform::emplace_back_rf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>emplace_back_rf</b></td></tr>
<tr class="separator:ae1eca5df73970c88fd79ae7bdc7d2f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c06ff16227a4ad2c65c12b1c13853b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52c06ff16227a4ad2c65c12b1c13853b"></a>
constexpr struct <a class="el" href="structatria_1_1xform_1_1first__rf__t.html">atria::xform::first_rf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>first_rf</b></td></tr>
<tr class="separator:a52c06ff16227a4ad2c65c12b1c13853b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8423ff0dd5cb5bf0a2abfa6b09cf25cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8423ff0dd5cb5bf0a2abfa6b09cf25cc"></a>
constexpr struct <a class="el" href="structatria_1_1xform_1_1last__rf__t.html">atria::xform::last_rf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>last_rf</b></td></tr>
<tr class="separator:a8423ff0dd5cb5bf0a2abfa6b09cf25cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a20f27def0ab94c670348cb9fa7f70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20a20f27def0ab94c670348cb9fa7f70"></a>
constexpr struct <a class="el" href="structatria_1_1xform_1_1output__rf__t.html">atria::xform::output_rf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>output_rf</b></td></tr>
<tr class="separator:a20a20f27def0ab94c670348cb9fa7f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b485b4a875fe8e2f2ccadbaa00563a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>skip_result_t&lt; ReducingFnT, StateT, InputTs...&gt;</b></td></tr>
<tr class="separator:a59b485b4a875fe8e2f2ccadbaa00563a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3db0b1325b015399b0d50f75e33220"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a7b3db0b1325b015399b0d50f75e33220">cat</a> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">cat_t</a> {}</td></tr>
<tr class="memdesc:a7b3db0b1325b015399b0d50f75e33220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/cat$1.  <a href="#a7b3db0b1325b015399b0d50f75e33220">More...</a><br /></td></tr>
<tr class="separator:a7b3db0b1325b015399b0d50f75e33220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6daf171c364c439a2595957a5d6b2d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">dedupe_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a4c6daf171c364c439a2595957a5d6b2d">dedupe</a> {}</td></tr>
<tr class="memdesc:a4c6daf171c364c439a2595957a5d6b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to clojure/dedupe$0.  <a href="#a4c6daf171c364c439a2595957a5d6b2d">More...</a><br /></td></tr>
<tr class="separator:a4c6daf171c364c439a2595957a5d6b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ceccfe79ea71598ee8534b2c7bade7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">distinct_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a71ceccfe79ea71598ee8534b2c7bade7">distinct</a> {}</td></tr>
<tr class="memdesc:a71ceccfe79ea71598ee8534b2c7bade7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to clojure/distinct$0.  <a href="#a71ceccfe79ea71598ee8534b2c7bade7">More...</a><br /></td></tr>
<tr class="separator:a71ceccfe79ea71598ee8534b2c7bade7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674e6c72a9862bb0968da41dfbcbedef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">enumerate_t</a>&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a674e6c72a9862bb0968da41dfbcbedef">enumerate</a></td></tr>
<tr class="memdesc:a674e6c72a9862bb0968da41dfbcbedef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>enumerate_from(std::size_t{})</code>.  <a href="#a674e6c72a9862bb0968da41dfbcbedef">More...</a><br /></td></tr>
<tr class="separator:a674e6c72a9862bb0968da41dfbcbedef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862d2b68690c1c4f277f48d9b677d5de"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a862d2b68690c1c4f277f48d9b677d5de">interleave</a> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">interleave_t</a> {}</td></tr>
<tr class="memdesc:a862d2b68690c1c4f277f48d9b677d5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to clojure.core/interleave$1.  <a href="#a862d2b68690c1c4f277f48d9b677d5de">More...</a><br /></td></tr>
<tr class="separator:a862d2b68690c1c4f277f48d9b677d5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df938e48fa1dd89e004f0d30e5cc3b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5df938e48fa1dd89e004f0d30e5cc3b0"></a>
stop&#160;</td><td class="memItemRight" valign="bottom"><b>start</b> { return ( comp( <a class="el" href="namespaceatria_1_1xform.html#a355c4a75a7b2d4a537ef915446b4e307">count</a>(start), <a class="el" href="namespaceatria_1_1xform.html#ad1392e213eac822dbbb8500608012bb4">take</a>(std::max(decltype(stop - start){}, stop - start))) )</td></tr>
<tr class="separator:a5df938e48fa1dd89e004f0d30e5cc3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df75b8aeff426ba305c87830a779fe9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6df75b8aeff426ba305c87830a779fe9"></a>
stop start&#160;</td><td class="memItemRight" valign="bottom"><b>step</b> { return ( comp( <a class="el" href="namespaceatria_1_1xform.html#a355c4a75a7b2d4a537ef915446b4e307">count</a>(start, step), <a class="el" href="namespaceatria_1_1xform.html#ad1392e213eac822dbbb8500608012bb4">take</a>(std::max(decltype((stop - start) / step){}, (stop - start) / step))) )</td></tr>
<tr class="separator:a6df75b8aeff426ba305c87830a779fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5308d966fbf95d317511a706d6d20a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#abe5308d966fbf95d317511a706d6d20a">unzip</a> = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">unzip_t</a> {}</td></tr>
<tr class="memdesc:abe5308d966fbf95d317511a706d6d20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducer that expands all tuples in the inputs in the argument list of the next transducer.  <a href="#abe5308d966fbf95d317511a706d6d20a">More...</a><br /></td></tr>
<tr class="separator:abe5308d966fbf95d317511a706d6d20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3002569b1ecc9b8b0e17d0de591c2915"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">map_t</a>&lt; tuplify_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatria_1_1xform.html#a3002569b1ecc9b8b0e17d0de591c2915">zip</a></td></tr>
<tr class="memdesc:a3002569b1ecc9b8b0e17d0de591c2915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducer that, if more than one argument is passed, forwards all of them as a single tuple.  <a href="#a3002569b1ecc9b8b0e17d0de591c2915">More...</a><br /></td></tr>
<tr class="separator:a3002569b1ecc9b8b0e17d0de591c2915"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Efficient and flexible C++ implementation of transducers. </p>
<p>Transducers where first introduced in <a href="http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming">Clojure by Rich Hickie</a> </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="af2572203f7496bd93e991b7dbaa2772e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceatria_1_1xform.html#af2572203f7496bd93e991b7dbaa2772e">maybe_reduced</a> =  <a class="el" href="structatria_1_1xform_1_1state__wrapper.html">state_wrapper</a>&lt;<a class="el" href="structatria_1_1xform_1_1maybe__reduced__tag.html">maybe_reduced_tag</a>, T, bool&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State wrapper for transducers that may want to signal that the reduction is finished. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structatria_1_1xform_1_1state__wrapper.html" title="A decorator for the accumulator of a reduction. ">state_wrapper</a> </dd>
<dd>
state_traits::reduced </dd></dl>

<p>Definition at line <a class="el" href="maybe__reduced_8hpp_source.html#l00048">48</a> of file <a class="el" href="maybe__reduced_8hpp_source.html">maybe_reduced.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12e4b8c9b4281bf93d4e649374f2d389"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceatria_1_1xform.html#a12e4b8c9b4281bf93d4e649374f2d389">transducer</a> =  <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">transducer_impl</a>&lt; <a class="el" href="namespaceatria_1_1meta.html#a11375eeae94b43372dd0f70a867f200f">meta::unpack</a>&lt;detail::transducer_rf_gen, OutputT&gt;, detail::transducer_function_t&lt;InputT, OutputT&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type erased transducer. </p>
<p>This allows to store transducers in places where the full type can not be known at compile time. The <code>InputT</code> template argument is the type of the input over which you may apply the transducer. For example:</p>
<div class="fragment"><div class="line">transducer&lt;int&gt; filter_odd = <a class="code" href="namespaceatria_1_1xform.html#a80ba27e99da8878464eb743b464c368e">filter</a>([] (<span class="keywordtype">int</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x % 2;</div>
<div class="line">});</div>
</div><!-- fragment --><p>A second template argument can be passed to indicate the type of data after running through the transducer. By default, it's the same as the input.</p>
<div class="fragment"><div class="line">transducer&lt;int, std::string&gt; serialize = <a class="code" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>([] (<span class="keywordtype">int</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(x);</div>
<div class="line">});</div>
</div><!-- fragment --><p>Both the first or second template arguments can take a <code><a class="el" href="structatria_1_1meta_1_1pack.html" title="MPL-compatible sequence that just holds a vector of types as a paremeter pack. ">meta::pack</a>&lt;&gt;</code> when it can take or pass more than one input type.</p>
<div class="fragment"><div class="line">transducer&lt;pack&lt;int, int&gt;, <span class="keywordtype">float</span>&gt; serialize = <a class="code" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>([] (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">    <span class="keywordflow">return</span> float(a) / float(b);</div>
<div class="line">});</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Type erased transducers have a performance cost. Not only is it slower to pass them around, they are significantly slower when processing the sequence. For such, use them when really needed, and otherwise use <code>auto</code> and templates to avoid erasing the types of the transducers.</dd>
<dd>
A type erased transducer actually defers applying the held transducer until it first runs through a sequence, as ilustrated by this example:</dd></dl>
<div class="fragment"><div class="line">transducer&lt;int&gt; filter_odd = [](<span class="keyword">auto</span> step) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Building step&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> [](<span class="keyword">auto</span> st, <span class="keywordtype">int</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x % 2 ? step(st, x) : st;</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Doesn&#39;t print anything</span></div>
<div class="line"><span class="keyword">auto</span> step = filter_odd(std::plus&lt;&gt;{});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now it prints</span></div>
<div class="line"><span class="keyword">auto</span> sum = <a class="code" href="namespaceatria_1_1xform.html#a85da5e5fc0bf1b8b7ccf1eaf11b7fd80">reduce</a>(step, 0, {1, 2, 3})</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="transducer_2transducer_8hpp_source.html#l00239">239</a> of file <a class="el" href="transducer_2transducer_8hpp_source.html">transducer.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6f09f6f468f00951f63d476cf3f200a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">atria::xform::ABL_CONCEPT_SPEC </td>
          <td>(</td>
          <td class="paramtype">State&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept for a type that can be used as a <code>state</code> of a reducing function. </p>
<p>By default, every type is a model of it. However, one might use this concept to check that a specialization of <code><a class="el" href="structatria_1_1xform_1_1state__traits.html" title="Interface for a type specializing the State concept. ">state_traits</a></code> is still valid. </p>

<p>Definition at line <a class="el" href="xform_2concepts_8hpp_source.html#l00042">42</a> of file <a class="el" href="xform_2concepts_8hpp_source.html">concepts.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d61103acf5e43b32458b61b4fb5c42f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">atria::xform::ABL_CONCEPT_SPEC </td>
          <td>(</td>
          <td class="paramtype">Reducing_function&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept for a function that can be used with <code>reduce</code> for a specific state and inputs. </p>

<p>Definition at line <a class="el" href="xform_2concepts_8hpp_source.html#l00068">68</a> of file <a class="el" href="xform_2concepts_8hpp_source.html">concepts.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80625416b5ebf0ce957cd1fd296ed80c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">atria::xform::ABL_CONCEPT_SPEC </td>
          <td>(</td>
          <td class="paramtype">Transducer&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept for a <code>transducer</code>, this is, a function that takes a <em>reducing function</em> as an argument, and decorates it returning a new <em>reducing function</em>. </p>
<p>The second and third argument use the same rules the arguments to <code>transducer</code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespaceatria_1_1xform.html#a12e4b8c9b4281bf93d4e649374f2d389" title="Type erased transducer. ">transducer</a></code> </dd></dl>

<p>Definition at line <a class="el" href="xform_2concepts_8hpp_source.html#l00124">124</a> of file <a class="el" href="xform_2concepts_8hpp_source.html">concepts.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae50c949c55e49a934999f8724e805309"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">atria::xform::ABL_CONCEPT_SPEC </td>
          <td>(</td>
          <td class="paramtype">Transparent_transducer&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept for a transducer that can be applied over any arguments. </p>

<p>Definition at line <a class="el" href="xform_2concepts_8hpp_source.html#l00150">150</a> of file <a class="el" href="xform_2concepts_8hpp_source.html">concepts.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2da0bbda0517148bb5c7a784235bf88c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto call </td>
          <td>(</td>
          <td class="paramtype">ReducingFnT &amp;&amp;&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StateT &amp;&amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceatria_1_1estd.html#a3d7e0f60f8c349b2a05f1fcf56750360">estd::enable_if_t</a>&lt;
    <a class="el" href="structatria_1_1xform_1_1is__skip__state.html">is_skip_state</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;StateT&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the next reducing function in a transducer that could otherwise skip calling the next reducing function. </p>
<p>Returns the result of calling <code>step(state, ins...)</code> wrapped in a type that can also hold plain <code>state</code> values. If <em>state</em> is wrapped in such a type, it unwraps it before passing it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceatria_1_1xform.html#a1cb9f11ae0e3df98b2c2e1f39f5302f2" title="Skip calling the next reducing function in a transducer. ">skip</a> </dd></dl>

<p>Definition at line <a class="el" href="skip_8hpp_source.html#l00246">246</a> of file <a class="el" href="skip_8hpp_source.html">skip.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2b85e8714c0aa88ddb6dcc59c3501e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto atria::xform::chain </td>
          <td>(</td>
          <td class="paramtype">InputRangeTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespaceatria_1_1xform.html#ad18c36bdd6e85b3a7f6584603386ec61">chainr</a>(std::forward&lt;InputRangeTs&gt;(rs)...) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <code>chainr</code> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceatria_1_1xform.html#ad18c36bdd6e85b3a7f6584603386ec61" title="Transducer produces the sequence passed as parameter after all other input has finished. ">chainr</a> </dd></dl>

<p>Definition at line <a class="el" href="chain_8hpp_source.html#l00103">103</a> of file <a class="el" href="chain_8hpp_source.html">chain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a70d85a17047adedbda1892ac046e092d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto atria::xform::chainl </td>
          <td>(</td>
          <td class="paramtype">InputRangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">chainl_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;InputRangeT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transducer produces the sequence passed as parameter before processing the first input. </p>

<p>Definition at line <a class="el" href="chain_8hpp_source.html#l00161">161</a> of file <a class="el" href="chain_8hpp_source.html">chain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad18c36bdd6e85b3a7f6584603386ec61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto atria::xform::chainr </td>
          <td>(</td>
          <td class="paramtype">InputRangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">chainr_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;InputRangeT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transducer produces the sequence passed as parameter after all other input has finished. </p>

<p>Definition at line <a class="el" href="chain_8hpp_source.html#l00085">85</a> of file <a class="el" href="chain_8hpp_source.html">chain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a355c4a75a7b2d4a537ef915446b4e307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto atria::xform::count </td>
          <td>(</td>
          <td class="paramtype">InitT&#160;</td>
          <td class="paramname"><em>init</em> = <code>InitT{0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StepT&#160;</td>
          <td class="paramname"><em>step</em> = <code>StepT{1}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">count_t</a>&lt;InitT, StepT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generator transducer produces a sequence: </p>
<p>$$init, init+step, ..., init+step*n$$</p>
<p>It is inspired by Python's <code>itertools.count</code> generator. </p>

<p>Definition at line <a class="el" href="count_8hpp_source.html#l00078">78</a> of file <a class="el" href="count_8hpp_source.html">count.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ca64e4188beed34b52a9ddc7e692bd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto atria::xform::cycle </td>
          <td>(</td>
          <td class="paramtype">InputRangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">cycle_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;InputRangeT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generator transducer produces the sequence passed as parameter, by cycleating over it. </p>

<p>Definition at line <a class="el" href="cycle_8hpp_source.html#l00090">90</a> of file <a class="el" href="cycle_8hpp_source.html">cycle.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01f108701be19ec8d379b9f6b0515e53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::drop </td>
          <td>(</td>
          <td class="paramtype">IntegralT &amp;&amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">drop_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;IntegralT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/drop$1. </p>

<p>Definition at line <a class="el" href="drop_8hpp_source.html#l00081">81</a> of file <a class="el" href="drop_8hpp_source.html">drop.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38696dd462d8382acbb53035db399d75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::drop_while </td>
          <td>(</td>
          <td class="paramtype">PredicateT &amp;&amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">drop_while_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;PredicateT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/drop_while$1. </p>

<p>Definition at line <a class="el" href="drop__while_8hpp_source.html#l00082">82</a> of file <a class="el" href="drop__while_8hpp_source.html">drop_while.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a075d51b9bc7bda8f0b27de56d38c33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto atria::xform::enumerate_from </td>
          <td>(</td>
          <td class="paramtype">IntegralT &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">enumerate_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;IntegralT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transducer that given a sequence: </p>
<p>$$x_0, x_1, ..., x_n$$</p>
<p>produces a sequence</p>
<p>$$(init, x_0), (init+1, x_1), ..., (init+n, x_n)$$</p>
<p>It is inspired by Python's <code>enumerate</code> generator. </p>

<p>Definition at line <a class="el" href="transducer_2enumerate_8hpp_source.html#l00100">100</a> of file <a class="el" href="transducer_2enumerate_8hpp_source.html">enumerate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80ba27e99da8878464eb743b464c368e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::filter </td>
          <td>(</td>
          <td class="paramtype">PredicateT &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">filter_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;PredicateT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/filter$1. </p>

<p>Definition at line <a class="el" href="filter_8hpp_source.html#l00082">82</a> of file <a class="el" href="filter_8hpp_source.html">filter.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a88287d69938c5ac4fb74dbbbe985a449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto atria::xform::interpose </td>
          <td>(</td>
          <td class="paramtype">ValueTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">interpose_t</a>&lt;estd::make_index_sequence&lt;sizeof...(ValueTs)&gt;,
                 std::tuple&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;ValueTs&gt;...&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like clojure.core/interpose$1. </p>

<p>Definition at line <a class="el" href="interpose_8hpp_source.html#l00096">96</a> of file <a class="el" href="interpose_8hpp_source.html">interpose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8acde91bb38a74e8111d03f72f991470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::into </td>
          <td>(</td>
          <td class="paramtype">CollectionT &amp;&amp;&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XformT &amp;&amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputRangeTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; CollectionT&amp;&amp;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/into$4. </p>

<p>Definition at line <a class="el" href="into_8hpp_source.html#l00048">48</a> of file <a class="el" href="into_8hpp_source.html">into.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac89301f0fadabb5c6ca41b05957d52eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::into_vector </td>
          <td>(</td>
          <td class="paramtype">XformT &amp;&amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputRangeTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; detail::into_vector_result_t&lt;XformT, InputRangeTs...&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/into-array. </p>

<p>Definition at line <a class="el" href="into__vector_8hpp_source.html#l00062">62</a> of file <a class="el" href="into__vector_8hpp_source.html">into_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acfab0c45a5f548e9a839f2060a45da77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto atria::xform::iter </td>
          <td>(</td>
          <td class="paramtype">InputRangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">iter_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;InputRangeT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generator transducer produces the sequence passed as parameter, by iterating over it. </p>

<p>Definition at line <a class="el" href="iter_8hpp_source.html#l00090">90</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f5d15acc0898885bc4386a7c9b41005"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::map </td>
          <td>(</td>
          <td class="paramtype">MappingT &amp;&amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">map_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;MappingT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/map$1. </p>

<p>Definition at line <a class="el" href="map_8hpp_source.html#l00079">79</a> of file <a class="el" href="map_8hpp_source.html">map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a84ac827e3b48e237ef49846ab4336e61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto atria::xform::map_indexed </td>
          <td>(</td>
          <td class="paramtype">MappingT &amp;&amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td> -&gt; decltype( comp(       <a class="el" href="namespaceatria_1_1xform.html#a355c4a75a7b2d4a537ef915446b4e307">count</a>(),       <a class="el" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>(std::forward&lt;MappingT&gt;(mapping))) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/map-indexed$1. </p>

<p>Definition at line <a class="el" href="map__indexed_8hpp_source.html#l00040">40</a> of file <a class="el" href="map__indexed_8hpp_source.html">map_indexed.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7934b802ca1cdc1dbd693ab99e908611"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::mapcat </td>
          <td>(</td>
          <td class="paramtype">MappingT &amp;&amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td> -&gt; decltype( comp(       <a class="el" href="namespaceatria_1_1xform.html#a7b3db0b1325b015399b0d50f75e33220">cat</a>,       <a class="el" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>(std::forward&lt;MappingT&gt;(mapping))) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/mapcat$1. </p>

<p>Definition at line <a class="el" href="mapcat_8hpp_source.html#l00040">40</a> of file <a class="el" href="mapcat_8hpp_source.html">mapcat.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a959ceb0a8362e3e5e4ef9f0a73a163c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::not_reduced </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespaceatria_1_1xform.html#a1cdbd85097477b77c5b4e744753e29b8">reduced_if</a>(std::forward&lt;T&gt;(x), false) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <em>x</em> such that the reduction should continue. </p>

<p>Definition at line <a class="el" href="maybe__reduced_8hpp_source.html#l00081">81</a> of file <a class="el" href="maybe__reduced_8hpp_source.html">maybe_reduced.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83103216261e92d2147ce41252272f76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::partition </td>
          <td>(</td>
          <td class="paramtype">IntegralT &amp;&amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">partition_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;IntegralT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/partition-all$1. </p>

<p>Definition at line <a class="el" href="partition_8hpp_source.html#l00112">112</a> of file <a class="el" href="partition_8hpp_source.html">partition.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a89e3ff42b7cdfce00041ef5be8c89efc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::partition_by </td>
          <td>(</td>
          <td class="paramtype">MappingT &amp;&amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">partition_by_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;MappingT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/partition-by$1. </p>

<p>Definition at line <a class="el" href="partition__by_8hpp_source.html#l00116">116</a> of file <a class="el" href="partition__by_8hpp_source.html">partition_by.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4fa098e18370e4117e3ae707e280d2bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto atria::xform::product </td>
          <td>(</td>
          <td class="paramtype">InputRangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">product_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;InputRangeT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transducer combines every element that passes by with every element in the sequence that it takes as arguemnt. </p>
<p>Like itertools.product, from Python. </p>

<p>Definition at line <a class="el" href="product_8hpp_source.html#l00090">90</a> of file <a class="el" href="product_8hpp_source.html">product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb6065c740d69641dc343d90814152b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::random_sample </td>
          <td>(</td>
          <td class="paramtype">ProbabilityT&#160;</td>
          <td class="paramname"><em>prob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GeneratorT&#160;</td>
          <td class="paramname"><em>generator</em> = <code>GeneratorT{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( <a class="el" href="namespaceatria_1_1xform.html#a80ba27e99da8878464eb743b464c368e">filter</a>(detail::random_sampler&lt;ProbabilityT, GeneratorT&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/random-sample$1. </p>

<p>Definition at line <a class="el" href="random__sample_8hpp_source.html#l00074">74</a> of file <a class="el" href="random__sample_8hpp_source.html">random_sample.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08e7c541dfbe38806edd2ddab4c6975b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto atria::xform::range </td>
          <td>(</td>
          <td class="paramtype">StopT &amp;&amp;&#160;</td>
          <td class="paramname"><em>stop</em></td><td>)</td>
          <td> -&gt; decltype( comp(       <a class="el" href="namespaceatria_1_1xform.html#a355c4a75a7b2d4a537ef915446b4e307">count</a>(),       <a class="el" href="namespaceatria_1_1xform.html#ad1392e213eac822dbbb8500608012bb4">take</a>(std::forward&lt;StopT&gt;(stop))) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generator transducer version of Python <code>range</code> </p>

<p>Definition at line <a class="el" href="range_8hpp_source.html#l00042">42</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a85da5e5fc0bf1b8b7ccf1eaf11b7fd80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::reduce </td>
          <td>(</td>
          <td class="paramtype">ReducingFnT &amp;&amp;&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StateT &amp;&amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputRangeTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;StateT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/reduce. </p>
<p>Unlike <code>std::accumulate</code>, this reduces over a range (doesn't take to distinct iterators) and can reduce over several ranges at the same time. It also supports early termination for transducers. </p>

<p>Definition at line <a class="el" href="reduce_8hpp_source.html#l00045">45</a> of file <a class="el" href="reduce_8hpp_source.html">reduce.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab186465bd44d27bfa0a657c96592c36e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::reduce_nested </td>
          <td>(</td>
          <td class="paramtype">ReducingFnT &amp;&amp;&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StateT &amp;&amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputRangeTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( detail::is_non_empty(ranges...)       ? <a class="el" href="namespaceatria_1_1xform.html#a2da0bbda0517148bb5c7a784235bf88c">call</a>(detail::reduce_nested_non_empty_flipped,              std::forward&lt;StateT&gt;(state),              std::forward&lt;ReducingFnT&gt;(step),              std::forward&lt;InputRangeTs&gt;(ranges)...)       : <a class="el" href="namespaceatria_1_1xform.html#a1cb9f11ae0e3df98b2c2e1f39f5302f2">skip</a>(std::forward&lt;StateT&gt;(state)) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <em>reduce</em>, but does not unwrap <code>reduced</code> values. </p>
<p>This is useful when calling reduce recursively inside a transducer. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceatria_1_1xform.html#ad1392e213eac822dbbb8500608012bb4" title="Similar to clojure.core/take$1. ">take</a> </dd></dl>

<p>Definition at line <a class="el" href="reduce__nested_8hpp_source.html#l00063">63</a> of file <a class="el" href="reduce__nested_8hpp_source.html">reduce_nested.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27b1401b1b47815969ff0867ad21f4e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::reduced </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespaceatria_1_1xform.html#a1cdbd85097477b77c5b4e744753e29b8">reduced_if</a>(std::forward&lt;T&gt;(x), true) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <em>x</em> such that the reduction should finish. </p>

<p>Definition at line <a class="el" href="maybe__reduced_8hpp_source.html#l00073">73</a> of file <a class="el" href="maybe__reduced_8hpp_source.html">maybe_reduced.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cdbd85097477b77c5b4e744753e29b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::reduced_if </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reduced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceatria_1_1xform.html#af2572203f7496bd93e991b7dbaa2772e">maybe_reduced</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;T&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <em>x</em> in a <code>maybe_reduced</code>, where <code>is_reduced</code> contains whether the reduction should actually finish. </p>

<p>Definition at line <a class="el" href="maybe__reduced_8hpp_source.html#l00060">60</a> of file <a class="el" href="maybe__reduced_8hpp_source.html">maybe_reduced.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad6801522a4749259f1da08257065abc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::remove </td>
          <td>(</td>
          <td class="paramtype">PredicateT &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespaceatria_1_1xform.html#a80ba27e99da8878464eb743b464c368e">filter</a>(complement(std::forward&lt;PredicateT&gt;(pred))) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/remove$1. </p>

<p>Definition at line <a class="el" href="remove_8hpp_source.html#l00040">40</a> of file <a class="el" href="remove_8hpp_source.html">remove.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a93215c74409bd3b594605eaa624d4d18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto atria::xform::repeat </td>
          <td>(</td>
          <td class="paramtype">ValueT &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">repeat_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;ValueT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generator transducer produces the values passed as parameter infinitely. </p>

<p>Definition at line <a class="el" href="repeat_8hpp_source.html#l00064">64</a> of file <a class="el" href="repeat_8hpp_source.html">repeat.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4654f2db5983fae5b5413baf5048bc9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto atria::xform::repeatn </td>
          <td>(</td>
          <td class="paramtype">IntegralT &amp;&amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( comp(<a class="el" href="namespaceatria_1_1xform.html#a93215c74409bd3b594605eaa624d4d18">repeat</a>(std::forward&lt;ValueTs&gt;(rs)...),          <a class="el" href="namespaceatria_1_1xform.html#ad1392e213eac822dbbb8500608012bb4">take</a>(std::forward&lt;IntegralT&gt;(n))) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generator transducer produces the values passed as parameter up to <code>n</code> times. </p>

<p>Definition at line <a class="el" href="repeat_8hpp_source.html#l00082">82</a> of file <a class="el" href="repeat_8hpp_source.html">repeat.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa04b4d4796efe53d507356cb40d10ea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::replace </td>
          <td>(</td>
          <td class="paramtype">TableT &amp;&amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>(detail::lookup_or_key&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;TableT&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/replace$1. </p>

<p>Definition at line <a class="el" href="replace_8hpp_source.html#l00093">93</a> of file <a class="el" href="replace_8hpp_source.html">replace.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af34877a89c42bfdf11a53c7218f71302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::replace_all </td>
          <td>(</td>
          <td class="paramtype">TableT &amp;&amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>(detail::lookup_default&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;TableT&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transducer that replaces all elements by <code>table[tuplify(inputs)]</code> </p>

<p>Definition at line <a class="el" href="replace_8hpp_source.html#l00101">101</a> of file <a class="el" href="replace_8hpp_source.html">replace.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaad19ba27a1533eb710ce84f9c300915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::replace_all_safe </td>
          <td>(</td>
          <td class="paramtype">TableT &amp;&amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>(detail::lookup_safe&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;TableT&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transducer that replaces all elements by <code>table.at(tuplify(inputs))</code> </p>

<p>Definition at line <a class="el" href="replace_8hpp_source.html#l00109">109</a> of file <a class="el" href="replace_8hpp_source.html">replace.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cb9f11ae0e3df98b2c2e1f39f5302f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::skip </td>
          <td>(</td>
          <td class="paramtype">ReducingFnT &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StateT &amp;&amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputTs &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; skip_result_t&lt;ReducingFnT, StateT, InputTs...&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip calling the next reducing function in a transducer. </p>
<p>Returns the <em>state</em> parameter, potentially wrapped in a value convertible to/from whatever <em>call</em> would return for similar parameters.</p>
<p>A transducer might or might not call the next reducing function in the chain. One good example is <em>filter</em>, where if the predicate passes, it calls the next reducing function, otherwise it just returns the current state of the reduction. However, this poses the question: what should be the return type of such a transducer? The next reducing function might wrap the state in a <em><a class="el" href="structatria_1_1xform_1_1state__wrapper.html" title="A decorator for the accumulator of a reduction. ">state_wrapper</a></em> to attach its own state to it. However, we don't know at this point what how to create such a wrapped value. This method, and <em>call</em>, take care of wrapping the state in a type that can hold values of both the current state, and the state that would be returned by the next reducing function. The metafunction <em><a class="el" href="structatria_1_1xform_1_1skip__result.html" title="Metafunction that returns a type that can hold both values of type skipped_t = StateT and wrapped_t =...">skip_result</a></em> defines such a type.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceatria_1_1xform.html#a2da0bbda0517148bb5c7a784235bf88c" title="Call the next reducing function in a transducer that could otherwise skip calling the next reducing f...">call</a> </dd>
<dd>
skip_result_t </dd>
<dd>
<a class="el" href="namespaceatria_1_1xform.html#a80ba27e99da8878464eb743b464c368e" title="Similar to clojure.core/filter$1. ">filter</a> </dd>
<dd>
<a class="el" href="namespaceatria_1_1xform.html#ae241d09b36ebe81badd419120047f7ab" title="Given a tag TagT and a state next and associated data, returns a state_wrapper instance. ">wrap_state</a> </dd></dl>

<p>Definition at line <a class="el" href="skip_8hpp_source.html#l00198">198</a> of file <a class="el" href="skip_8hpp_source.html">skip.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a742ad6e9cabc139c89bf66d8dc78c9ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::state_complete </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="structatria_1_1xform_1_1state__traits.html">state_traits_t</a>&lt;T&gt;::complete(std::forward&lt;T&gt;(s)) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for calling <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#a18456c946a84c9b57eb4e0bd2732024a" title="Unwraps all the layers of state wrappers returning the deepmost. ">state_traits::complete</a></code> </p>

<p>Definition at line <a class="el" href="state__traits_8hpp_source.html#l00093">93</a> of file <a class="el" href="state__traits_8hpp_source.html">state_traits.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a583e716efb1c0c996c31fa249ba1f7fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::state_data </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D &amp;&amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( <a class="el" href="structatria_1_1xform_1_1state__traits.html">state_traits_t</a>&lt;T&gt;::data(std::forward&lt;T&gt;(s),                             std::forward&lt;D&gt;(d)) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for calling <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#ac09e5ef6d0902f21a633c3b7105e95ef" title="Returns the associated from the current state. ">state_traits::data</a></code> </p>

<p>Definition at line <a class="el" href="state__traits_8hpp_source.html#l00110">110</a> of file <a class="el" href="state__traits_8hpp_source.html">state_traits.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa3bd5ac59b27e0db927043add4734650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::state_is_reduced </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for calling <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#a90d4465e97d7fd11c872c25e5ad13ce4" title="Returns whether the value is idempotent, and thus, the reduction can finish. ">state_traits::is_reduced</a></code> </p>

<p>Definition at line <a class="el" href="state__traits_8hpp_source.html#l00101">101</a> of file <a class="el" href="state__traits_8hpp_source.html">state_traits.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f3d5f97c45a219e65ba34cd3838e7ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::state_unwrap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="structatria_1_1xform_1_1state__traits.html">state_traits_t</a>&lt;T&gt;::unwrap(std::forward&lt;T&gt;(s)) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for calling <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#a7a61e1d47a98a6262eeb5d3c1dc17a89" title="Unwraps this layers of state wrappers, returning the nested state for the next reducing function...">state_traits::unwrap</a></code> </p>

<p>Definition at line <a class="el" href="state__traits_8hpp_source.html#l00119">119</a> of file <a class="el" href="state__traits_8hpp_source.html">state_traits.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e2b263b3e03295e68676c7df069f328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::state_wrapper_complete </td>
          <td>(</td>
          <td class="paramtype">TagT&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( <a class="el" href="namespaceatria_1_1xform.html#a742ad6e9cabc139c89bf66d8dc78c9ca">state_complete</a>(<a class="el" href="namespaceatria_1_1xform.html#a8f3d5f97c45a219e65ba34cd3838e7ed">state_unwrap</a>(std::forward&lt;T&gt;(s))) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for easy overloading of <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#a18456c946a84c9b57eb4e0bd2732024a" title="Unwraps all the layers of state wrappers returning the deepmost. ">state_traits::complete</a></code> for state wrappers with a specific tag. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structatria_1_1xform_1_1state__wrapper.html" title="A decorator for the accumulator of a reduction. ">state_wrapper</a> </dd>
<dd>
<a class="el" href="structatria_1_1xform_1_1state__traits.html#a18456c946a84c9b57eb4e0bd2732024a" title="Unwraps all the layers of state wrappers returning the deepmost. ">state_traits::complete</a> </dd></dl>

<p>Definition at line <a class="el" href="state__wrapper_8hpp_source.html#l00123">123</a> of file <a class="el" href="state__wrapper_8hpp_source.html">state_wrapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8100207fd3c7ddf71e629248b76a184b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::state_wrapper_data </td>
          <td>(</td>
          <td class="paramtype">TagT&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( state_wrapper_data(tag, std::forward&lt;T&gt;(s)) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for easy overloading of <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#ac09e5ef6d0902f21a633c3b7105e95ef" title="Returns the associated from the current state. ">state_traits::data</a></code> for state wrappers with a specific tag. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structatria_1_1xform_1_1state__wrapper.html" title="A decorator for the accumulator of a reduction. ">state_wrapper</a> </dd>
<dd>
<a class="el" href="structatria_1_1xform_1_1state__traits.html#ac09e5ef6d0902f21a633c3b7105e95ef" title="Returns the associated from the current state. ">state_traits::data</a> </dd></dl>

<p>Definition at line <a class="el" href="state__wrapper_8hpp_source.html#l00147">147</a> of file <a class="el" href="state__wrapper_8hpp_source.html">state_wrapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af74cc4a347fd2ad83c01a0c7c35292de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atria::xform::state_wrapper_data_is_reduced </td>
          <td>(</td>
          <td class="paramtype">TagT&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataT &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function that returns whether the <code>DataT</code> associated with a state wrapper with tag <code>TagT</code> is reduced &ndash; i.e. </p>
<p>idempotent. Can be overloaded custom tags.</p>
<dl class="section see"><dt>See also</dt><dd>state_traits::reduced </dd></dl>

<p>Definition at line <a class="el" href="state__wrapper_8hpp_source.html#l00169">169</a> of file <a class="el" href="state__wrapper_8hpp_source.html">state_wrapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab2250f9477d337be124b73f3ad9d2c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atria::xform::state_wrapper_is_reduced </td>
          <td>(</td>
          <td class="paramtype">TagT&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for easy overloading of <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#a90d4465e97d7fd11c872c25e5ad13ce4" title="Returns whether the value is idempotent, and thus, the reduction can finish. ">state_traits::is_reduced</a></code> for state wrappers with a specific tag. </p>
<p>Most of the time you may want to overload <code>state_wrapper_is_reduced</code> instead.</p>
<dl class="section see"><dt>See also</dt><dd>state_wrapper_data_is_reduced </dd>
<dd>
<a class="el" href="structatria_1_1xform_1_1state__wrapper.html" title="A decorator for the accumulator of a reduction. ">state_wrapper</a> </dd>
<dd>
<a class="el" href="structatria_1_1xform_1_1state__traits.html#a90d4465e97d7fd11c872c25e5ad13ce4" title="Returns whether the value is idempotent, and thus, the reduction can finish. ">state_traits::is_reduced</a> </dd></dl>

<p>Definition at line <a class="el" href="state__wrapper_8hpp_source.html#l00184">184</a> of file <a class="el" href="state__wrapper_8hpp_source.html">state_wrapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a1356003e10762cec1b6e68b4676ee8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::state_wrapper_unwrap </td>
          <td>(</td>
          <td class="paramtype">TagT&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( std::get&lt;0&gt;(std::forward&lt;T&gt;(s)) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for easy overloading of <code><a class="el" href="structatria_1_1xform_1_1state__traits.html#a7a61e1d47a98a6262eeb5d3c1dc17a89" title="Unwraps this layers of state wrappers, returning the nested state for the next reducing function...">state_traits::unwrap</a></code> for state wrappers with a specific tag. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structatria_1_1xform_1_1state__wrapper.html" title="A decorator for the accumulator of a reduction. ">state_wrapper</a> </dd>
<dd>
<a class="el" href="structatria_1_1xform_1_1state__traits.html#a7a61e1d47a98a6262eeb5d3c1dc17a89" title="Unwraps this layers of state wrappers, returning the nested state for the next reducing function...">state_traits::unwrap</a> </dd></dl>

<p>Definition at line <a class="el" href="state__wrapper_8hpp_source.html#l00135">135</a> of file <a class="el" href="state__wrapper_8hpp_source.html">state_wrapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad1392e213eac822dbbb8500608012bb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::take </td>
          <td>(</td>
          <td class="paramtype">IntegralT &amp;&amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">take_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;IntegralT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/take$1. </p>

<p>Definition at line <a class="el" href="transducer_2take_8hpp_source.html#l00087">87</a> of file <a class="el" href="transducer_2take_8hpp_source.html">take.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17787884a59f85db0f31190809a9de80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::take_nth </td>
          <td>(</td>
          <td class="paramtype">IntegralT &amp;&amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">take_nth_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;IntegralT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/take_nth$1. </p>

<p>Definition at line <a class="el" href="take__nth_8hpp_source.html#l00126">126</a> of file <a class="el" href="take__nth_8hpp_source.html">take_nth.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a68949f8b8b3369cd89c0f5e522b762c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::take_while </td>
          <td>(</td>
          <td class="paramtype">PredicateT &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">take_while_t</a>&lt;<a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;PredicateT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/take_while$1. </p>

<p>Definition at line <a class="el" href="take__while_8hpp_source.html#l00072">72</a> of file <a class="el" href="take__while_8hpp_source.html">take_while.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1c5626f067144894d8ba89075c02120a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::traced </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespaceatria_1_1xform.html#a9f5d15acc0898885bc4386a7c9b41005">map</a>(tracer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transducer that traces the values values that pass through it and forwards them forward in the chain. </p>
<dl class="section see"><dt>See also</dt><dd>trace </dd>
<dd>
tracer </dd></dl>

<p>Definition at line <a class="el" href="traced_8hpp_source.html#l00041">41</a> of file <a class="el" href="traced_8hpp_source.html">traced.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa3ddac4a321b0ab20393f47485e42a50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::transduce </td>
          <td>(</td>
          <td class="paramtype">XformT &amp;&amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReducingFnT &amp;&amp;&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StateT &amp;&amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputRangeTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;StateT&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/transduce. </p>

<p>Definition at line <a class="el" href="transduce_8hpp_source.html#l00041">41</a> of file <a class="el" href="transduce_8hpp_source.html">transduce.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ade4a7505add816a4798fcb3cc96c7e7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto with_state </td>
          <td>(</td>
          <td class="paramtype">StateT &amp;&amp;&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnwrappedFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WrappedFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; meta::lazy_enable_if_t&lt;
    !std::is_same&lt;
      <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;StateT&gt;,
      <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;decltype(<a class="el" href="namespaceatria_1_1xform.html#a742ad6e9cabc139c89bf66d8dc78c9ca">state_complete</a>(st))&gt;
    &gt;::value,
    std::result_of&lt;WrappedFn(StateT)&gt;
  &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a value <code>st</code> that represents the state of a reduction, this function generically dispatches to the right function <code>UnwrappedFn</code> or <code>WrappedFn</code>, depending of whether the value is already wrapped or not. </p>
<p>This is, during the first iteration of the reduction, <code>UnwrappedFn</code> will be called, from then on, <code>WrappedFnT</code> will be called.</p>
<p>The signatures should be of the form:</p>
<ul>
<li><code>UnwrappedFn : A -&gt; B</code></li>
<li><code>WrappedFn : B -&gt; B</code></li>
</ul>
<p>This function can dispatch both statically and dynamically in a transparent way. It is thus very useful for writing stateful transducers that can be type erased in a <code>transducer&lt;&gt;</code> object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceatria_1_1xform.html#a12e4b8c9b4281bf93d4e649374f2d389" title="Type erased transducer. ">transducer</a> </dd>
<dd>
<a class="el" href="namespaceatria_1_1xform.html#ad1392e213eac822dbbb8500608012bb4" title="Similar to clojure.core/take$1. ">take</a> </dd></dl>

<p>Definition at line <a class="el" href="with__state_8hpp_source.html#l00058">58</a> of file <a class="el" href="with__state_8hpp_source.html">with_state.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae241d09b36ebe81badd419120047f7ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto atria::xform::wrap_state </td>
          <td>(</td>
          <td class="paramtype">StateT &amp;&amp;&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataT &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em> = <code>DataT{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structatria_1_1xform_1_1state__wrapper.html">state_wrapper</a>&lt;TagT,
                   <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;StateT&gt;,
                   <a class="el" href="namespaceatria_1_1estd.html#abccbc22bdad41d01de217a42e0d077ff">estd::decay_t</a>&lt;DataT&gt; &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a tag <code>TagT</code> and a state <code>next</code> and associated <code>data</code>, returns a <code><a class="el" href="structatria_1_1xform_1_1state__wrapper.html" title="A decorator for the accumulator of a reduction. ">state_wrapper</a></code> instance. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structatria_1_1xform_1_1state__wrapper.html" title="A decorator for the accumulator of a reduction. ">state_wrapper</a> </dd></dl>

<p>Definition at line <a class="el" href="state__wrapper_8hpp_source.html#l00104">104</a> of file <a class="el" href="state__wrapper_8hpp_source.html">state_wrapper.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a7b3db0b1325b015399b0d50f75e33220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cat = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">cat_t</a> {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/cat$1. </p>

<p>Definition at line <a class="el" href="cat_8hpp_source.html#l00060">60</a> of file <a class="el" href="cat_8hpp_source.html">cat.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c6daf171c364c439a2595957a5d6b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">dedupe_t</a> dedupe {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to clojure/dedupe$0. </p>

<p>Definition at line <a class="el" href="dedupe_8hpp_source.html#l00088">88</a> of file <a class="el" href="dedupe_8hpp_source.html">dedupe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a71ceccfe79ea71598ee8534b2c7bade7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">distinct_t</a> distinct {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to clojure/distinct$0. </p>

<p>Definition at line <a class="el" href="distinct_8hpp_source.html#l00093">93</a> of file <a class="el" href="distinct_8hpp_source.html">distinct.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a674e6c72a9862bb0968da41dfbcbedef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">enumerate_t</a>&lt;std::size_t&gt; enumerate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>enumerate_from(std::size_t{})</code>. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Should be <code>constexpr</code> in C++14 </dd></dl>

</div>
</div>
<a class="anchor" id="a862d2b68690c1c4f277f48d9b677d5de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto interleave = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">interleave_t</a> {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to clojure.core/interleave$1. </p>

<p>Definition at line <a class="el" href="interleave_8hpp_source.html#l00077">77</a> of file <a class="el" href="interleave_8hpp_source.html">interleave.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59b485b4a875fe8e2f2ccadbaa00563a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">skip_result_t&lt; ReducingFnT, StateT, InputTs...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> std::forward&lt;ReducingFnT&gt;(step)(</div>
<div class="line">    std::forward&lt;StateT&gt;(state),</div>
<div class="line">    std::forward&lt;InputTs&gt;(ins)...)</div>
</div><!-- fragment -->
<p>Definition at line <a class="el" href="skip_8hpp_source.html#l00264">264</a> of file <a class="el" href="skip_8hpp_source.html">skip.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe5308d966fbf95d317511a706d6d20a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unzip = <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">unzip_t</a> {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transducer that expands all tuples in the inputs in the argument list of the next transducer. </p>

<p>Definition at line <a class="el" href="unzip_8hpp_source.html#l00187">187</a> of file <a class="el" href="unzip_8hpp_source.html">unzip.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3002569b1ecc9b8b0e17d0de591c2915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structatria_1_1xform_1_1transducer__impl.html">map_t</a>&lt;tuplify_t&gt; zip</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transducer that, if more than one argument is passed, forwards all of them as a single tuple. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>This should a <code>constexpr</code> in C++14 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 19 2015 12:55:41 for Atria by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
<a href="https://github.com/abletonag/atria">
  <img style="position: absolute; top: 0; right: 0; border: 0;"
       src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67"
       alt="Fork me on GitHub"
       data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"/>
</a>
</body>
</html>
